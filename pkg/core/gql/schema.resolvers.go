package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"
	"time"

	"github.com/AudiusProject/audiusd/pkg/core/db"
	"github.com/AudiusProject/audiusd/pkg/core/gen/core_gql"
	"github.com/jackc/pgx/v5/pgtype"
)

func (r *queryGraphQLServer) GetBlock(ctx context.Context, height *int) (*core_gql.Block, error) {
	block, err := r.db.GetBlock(ctx, int64(*height))
	if err != nil {
		return nil, err
	}

	txs, err := r.db.GetBlockTransactions(ctx, block.Height)
	if err != nil {
		return nil, err
	}

	transactions := []*core_gql.Transaction{}
	for _, tx := range txs {
		transactions = append(transactions, &core_gql.Transaction{
			Index: int(tx.Index),
			Hash:  tx.TxHash,
		})
	}

	return &core_gql.Block{
		Height:       int(block.Height),
		ChainID:      block.ChainID,
		Hash:         block.Hash,
		Proposer:     block.Proposer,
		Transactions: transactions,
	}, nil
}

func (r *queryGraphQLServer) GetLatestBlock(ctx context.Context) (*core_gql.Block, error) {
	block, err := r.db.GetLatestBlock(ctx)
	if err != nil {
		return nil, err
	}

	txs, err := r.db.GetBlockTransactions(ctx, block.Height)
	if err != nil {
		return nil, err
	}

	transactions := []*core_gql.Transaction{}
	for _, tx := range txs {
		transactions = append(transactions, &core_gql.Transaction{
			Index: int(tx.Index),
			Hash:  tx.TxHash,
		})
	}

	return &core_gql.Block{
		Height:       int(block.Height),
		ChainID:      block.ChainID,
		Hash:         block.Hash,
		Proposer:     block.Proposer,
		Transactions: transactions,
	}, nil
}

func (r *queryGraphQLServer) GetLatestBlocks(ctx context.Context, limit *int) ([]*core_gql.Block, error) {
	// Default limit to 10 if not specified
	l := int32(10)
	if limit != nil {
		l = int32(*limit)
	}

	blocks, err := r.db.GetRecentBlocks(ctx, l)
	if err != nil {
		return nil, err
	}

	result := []*core_gql.Block{}
	for _, block := range blocks {
		txs, err := r.db.GetBlockTransactions(ctx, block.Height)
		if err != nil {
			return nil, err
		}

		transactions := []*core_gql.Transaction{}
		for _, tx := range txs {
			transactions = append(transactions, &core_gql.Transaction{
				Index: int(tx.Index),
				Hash:  tx.TxHash,
			})
		}

		result = append(result, &core_gql.Block{
			Height:       int(block.Height),
			ChainID:      block.ChainID,
			Hash:         block.Hash,
			Proposer:     block.Proposer,
			Transactions: transactions,
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetAvailableCities(ctx context.Context, filter *core_gql.LocationCityFilter, limit *int) ([]*core_gql.LocationCity, error) {
	l := int32(10)
	if limit != nil {
		l = int32(*limit)
	}

	// Handle optional filters
	country := ""
	region := ""
	if filter != nil {
		if filter.Country != nil {
			country = *filter.Country
		}
		if filter.Region != nil {
			region = *filter.Region
		}
	}

	cities, err := r.db.GetAvailableCities(ctx, db.GetAvailableCitiesParams{
		Column1: country,
		Column2: region,
		Limit:   l,
	})
	if err != nil {
		return nil, err
	}

	result := []*core_gql.LocationCity{}
	for _, city := range cities {
		result = append(result, &core_gql.LocationCity{
			City:      city.City.String,
			Region:    city.Region.String,
			Country:   city.Country.String,
			PlayCount: int(city.PlayCount),
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetAvailableRegions(ctx context.Context, filter *core_gql.LocationRegionFilter, limit *int) ([]*core_gql.LocationRegion, error) {
	l := int32(10)
	if limit != nil {
		l = int32(*limit)
	}

	// Handle optional filter
	country := ""
	if filter != nil && filter.Country != nil {
		country = *filter.Country
	}

	regions, err := r.db.GetAvailableRegions(ctx, db.GetAvailableRegionsParams{
		Column1: country,
		Limit:   l,
	})
	if err != nil {
		return nil, err
	}

	result := []*core_gql.LocationRegion{}
	for _, region := range regions {
		result = append(result, &core_gql.LocationRegion{
			Region:    region.Region.String,
			Country:   region.Country.String,
			PlayCount: int(region.PlayCount),
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetAvailableCountries(ctx context.Context, limit *int) ([]*core_gql.LocationCountry, error) {
	l := int32(10)
	if limit != nil {
		l = int32(*limit)
	}

	countries, err := r.db.GetAvailableCountries(ctx, l)
	if err != nil {
		return nil, err
	}

	result := []*core_gql.LocationCountry{}
	for _, country := range countries {
		result = append(result, &core_gql.LocationCountry{
			Country:   country.Country.String,
			PlayCount: int(country.PlayCount),
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetTransaction(ctx context.Context, hash string) (*core_gql.Transaction, error) {
	tx, err := r.db.GetTx(ctx, hash)
	if err != nil {
		return nil, err
	}

	// Get block height from block ID
	block, err := r.db.GetBlock(ctx, tx.BlockID)
	if err != nil {
		return nil, err
	}

	return &core_gql.Transaction{
		Index:       int(tx.Index),
		Hash:        tx.TxHash,
		BlockHeight: int(block.Height),
		Data:        string(tx.Transaction),
		Type:        nil, // TODO: Implement transaction type detection from tx data
	}, nil
}

func (r *queryGraphQLServer) GetLatestTransactions(ctx context.Context, limit *int) ([]*core_gql.Transaction, error) {
	// Default limit to 10 if not specified
	l := int32(10)
	if limit != nil {
		l = int32(*limit)
	}

	txs, err := r.db.GetRecentTxs(ctx, l)
	if err != nil {
		return nil, err
	}

	result := []*core_gql.Transaction{}
	for _, tx := range txs {
		// Get block height from block ID
		block, err := r.db.GetBlock(ctx, tx.BlockID)
		if err != nil {
			return nil, err
		}

		result = append(result, &core_gql.Transaction{
			Index:       int(tx.Index),
			Hash:        tx.TxHash,
			BlockHeight: int(block.Height),
			Data:        string(tx.Transaction),
			Type:        nil, // TODO: Implement transaction type detection from tx data
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetDecodedTransaction(ctx context.Context, hash string) (*core_gql.DecodedTransaction, error) {
	tx, err := r.db.GetDecodedTx(ctx, hash)
	if err != nil {
		return nil, err
	}

	return &core_gql.DecodedTransaction{
		BlockHeight: int(tx.BlockHeight),
		TxIndex:     int(tx.TxIndex),
		TxHash:      tx.TxHash,
		TxType:      tx.TxType,
		TxData:      string(tx.TxData),
		CreatedAt:   tx.CreatedAt.Time.String(),
	}, nil
}

func (r *queryGraphQLServer) GetLatestDecodedTransactions(ctx context.Context, limit *int) ([]*core_gql.DecodedTransaction, error) {
	l := int32(10)
	if limit != nil {
		l = int32(*limit)
	}

	txs, err := r.db.GetLatestDecodedTxs(ctx, l)
	if err != nil {
		return nil, err
	}

	result := []*core_gql.DecodedTransaction{}
	for _, tx := range txs {
		result = append(result, &core_gql.DecodedTransaction{
			BlockHeight: int(tx.BlockHeight),
			TxIndex:     int(tx.TxIndex),
			TxHash:      tx.TxHash,
			TxType:      tx.TxType,
			TxData:      string(tx.TxData),
			CreatedAt:   tx.CreatedAt.Time.String(),
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetDecodedTransactionsByType(ctx context.Context, txType string, limit *int) ([]*core_gql.DecodedTransaction, error) {
	l := int32(10)
	if limit != nil {
		l = int32(*limit)
	}

	txs, err := r.db.GetDecodedTxsByType(ctx, db.GetDecodedTxsByTypeParams{
		TxType: txType,
		Limit:  l,
	})
	if err != nil {
		return nil, err
	}

	result := []*core_gql.DecodedTransaction{}
	for _, tx := range txs {
		result = append(result, &core_gql.DecodedTransaction{
			BlockHeight: int(tx.BlockHeight),
			TxIndex:     int(tx.TxIndex),
			TxHash:      tx.TxHash,
			TxType:      tx.TxType,
			TxData:      string(tx.TxData),
			CreatedAt:   tx.CreatedAt.Time.String(),
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetDecodedTransactionsByBlock(ctx context.Context, height int) ([]*core_gql.DecodedTransaction, error) {
	txs, err := r.db.GetDecodedTxsByBlock(ctx, int64(height))
	if err != nil {
		return nil, err
	}

	result := []*core_gql.DecodedTransaction{}
	for _, tx := range txs {
		result = append(result, &core_gql.DecodedTransaction{
			BlockHeight: int(tx.BlockHeight),
			TxIndex:     int(tx.TxIndex),
			TxHash:      tx.TxHash,
			TxType:      tx.TxType,
			TxData:      string(tx.TxData),
			CreatedAt:   tx.CreatedAt.Time.String(),
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetDecodedPlays(ctx context.Context, limit *int) ([]*core_gql.DecodedPlay, error) {
	l := int32(10)
	if limit != nil {
		l = int32(*limit)
	}

	plays, err := r.db.GetDecodedPlays(ctx, l)
	if err != nil {
		return nil, err
	}

	result := []*core_gql.DecodedPlay{}
	for _, play := range plays {
		result = append(result, &core_gql.DecodedPlay{
			TxHash:    play.TxHash,
			UserID:    play.UserID,
			TrackID:   play.TrackID,
			PlayedAt:  play.PlayedAt.Time.String(),
			Signature: play.Signature,
			City:      &play.City.String,
			Region:    &play.Region.String,
			Country:   &play.Country.String,
			CreatedAt: play.CreatedAt.Time.String(),
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetDecodedPlaysByUser(ctx context.Context, userID string, limit *int) ([]*core_gql.DecodedPlay, error) {
	l := int32(10)
	if limit != nil {
		l = int32(*limit)
	}

	plays, err := r.db.GetDecodedPlaysByUser(ctx, db.GetDecodedPlaysByUserParams{
		UserID: userID,
		Limit:  l,
	})
	if err != nil {
		return nil, err
	}

	result := []*core_gql.DecodedPlay{}
	for _, play := range plays {
		result = append(result, &core_gql.DecodedPlay{
			TxHash:    play.TxHash,
			UserID:    play.UserID,
			TrackID:   play.TrackID,
			PlayedAt:  play.PlayedAt.Time.String(),
			Signature: play.Signature,
			City:      &play.City.String,
			Region:    &play.Region.String,
			Country:   &play.Country.String,
			CreatedAt: play.CreatedAt.Time.String(),
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetDecodedPlaysByTrack(ctx context.Context, trackID string, limit *int) ([]*core_gql.DecodedPlay, error) {
	l := int32(10)
	if limit != nil {
		l = int32(*limit)
	}

	plays, err := r.db.GetDecodedPlaysByTrack(ctx, db.GetDecodedPlaysByTrackParams{
		TrackID: trackID,
		Limit:   l,
	})
	if err != nil {
		return nil, err
	}

	result := []*core_gql.DecodedPlay{}
	for _, play := range plays {
		result = append(result, &core_gql.DecodedPlay{
			TxHash:    play.TxHash,
			UserID:    play.UserID,
			TrackID:   play.TrackID,
			PlayedAt:  play.PlayedAt.Time.String(),
			Signature: play.Signature,
			City:      &play.City.String,
			Region:    &play.Region.String,
			Country:   &play.Country.String,
			CreatedAt: play.CreatedAt.Time.String(),
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetDecodedPlaysByTimeRange(ctx context.Context, startTime string, endTime string, limit *int) ([]*core_gql.DecodedPlay, error) {
	l := int32(10)
	if limit != nil {
		l = int32(*limit)
	}

	// Parse the time strings into time.Time
	startTimestamp, err := time.Parse(time.RFC3339, startTime)
	if err != nil {
		return nil, fmt.Errorf("invalid start time format: %v", err)
	}

	endTimestamp, err := time.Parse(time.RFC3339, endTime)
	if err != nil {
		return nil, fmt.Errorf("invalid end time format: %v", err)
	}

	plays, err := r.db.GetDecodedPlaysByTimeRange(ctx, db.GetDecodedPlaysByTimeRangeParams{
		PlayedAt:   pgtype.Timestamptz{Time: startTimestamp, Valid: true},
		PlayedAt_2: pgtype.Timestamptz{Time: endTimestamp, Valid: true},
		Limit:      l,
	})
	if err != nil {
		return nil, err
	}

	result := []*core_gql.DecodedPlay{}
	for _, play := range plays {
		result = append(result, &core_gql.DecodedPlay{
			TxHash:    play.TxHash,
			UserID:    play.UserID,
			TrackID:   play.TrackID,
			PlayedAt:  play.PlayedAt.Time.String(),
			Signature: play.Signature,
			City:      &play.City.String,
			Region:    &play.Region.String,
			Country:   &play.Country.String,
			CreatedAt: play.CreatedAt.Time.String(),
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetDecodedPlaysByLocation(ctx context.Context, location core_gql.LocationFilter, limit *int) ([]*core_gql.DecodedPlay, error) {
	l := int32(10)
	if limit != nil {
		l = int32(*limit)
	}

	// Convert optional string pointers to strings, empty string if nil
	city := ""
	if location.City != nil {
		city = *location.City
	}
	region := ""
	if location.Region != nil {
		region = *location.Region
	}
	country := ""
	if location.Country != nil {
		country = *location.Country
	}

	plays, err := r.db.GetDecodedPlaysByLocation(ctx, db.GetDecodedPlaysByLocationParams{
		Column1: city,
		Column2: region,
		Column3: country,
		Limit:   l,
	})
	if err != nil {
		return nil, err
	}

	result := []*core_gql.DecodedPlay{}
	for _, play := range plays {
		result = append(result, &core_gql.DecodedPlay{
			TxHash:    play.TxHash,
			UserID:    play.UserID,
			TrackID:   play.TrackID,
			PlayedAt:  play.PlayedAt.Time.String(),
			Signature: play.Signature,
			City:      &play.City.String,
			Region:    &play.Region.String,
			Country:   &play.Country.String,
			CreatedAt: play.CreatedAt.Time.String(),
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetAnalytics(ctx context.Context) (*core_gql.Analytics, error) {
	totalBlocks, err := r.db.TotalBlocks(ctx)
	if err != nil {
		return nil, err
	}

	totalTxs, err := r.db.TotalTransactions(ctx)
	if err != nil {
		return nil, err
	}

	totalPlays, err := r.db.TotalTransactionsByType(ctx, "TrackPlays")
	if err != nil {
		return nil, err
	}

	totalManageEntities, err := r.db.TotalTransactionsByType(ctx, "ManageEntity")
	if err != nil {
		return nil, err
	}

	totalValidators, err := r.db.TotalValidators(ctx)
	if err != nil {
		return nil, err
	}

	return &core_gql.Analytics{
		TotalBlocks:         int(totalBlocks),
		TotalTransactions:   int(totalTxs),
		TotalPlays:          int(totalPlays),
		TotalValidators:     int(totalValidators),
		TotalManageEntities: int(totalManageEntities),
	}, nil
}

func (r *queryGraphQLServer) GetTransactionStats(ctx context.Context, hours *int) ([]*core_gql.TransactionStat, error) {
	stats, err := r.db.TxsPerHour(ctx)
	if err != nil {
		return nil, err
	}

	result := []*core_gql.TransactionStat{}
	for _, stat := range stats {
		result = append(result, &core_gql.TransactionStat{
			Hour:    stat.Hour.Time.String(),
			TxCount: int(stat.TxCount),
			TxType:  stat.TxType,
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetAllNodes(ctx context.Context) ([]*core_gql.Node, error) {
	nodes, err := r.db.GetAllRegisteredNodes(ctx)
	if err != nil {
		return nil, err
	}

	result := []*core_gql.Node{}
	for _, node := range nodes {
		result = append(result, &core_gql.Node{
			Address:      node.CometAddress,
			Endpoint:     node.Endpoint,
			EthAddress:   node.EthAddress,
			CometAddress: node.CometAddress,
			CometPubKey:  &node.CometPubKey,
			NodeType:     node.NodeType,
			SpID:         &node.SpID,
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetNode(ctx context.Context, address string) (*core_gql.Node, error) {
	nodes, err := r.db.GetAllRegisteredNodes(ctx)
	if err != nil {
		return nil, err
	}

	// Find the node with matching address
	for _, node := range nodes {
		if node.CometAddress == address {
			return &core_gql.Node{
				Address:      node.CometAddress,
				Endpoint:     node.Endpoint,
				EthAddress:   node.EthAddress,
				CometAddress: node.CometAddress,
				CometPubKey:  &node.CometPubKey,
				NodeType:     node.NodeType,
				SpID:         &node.SpID,
			}, nil
		}
	}
	return nil, fmt.Errorf("node not found")
}

func (r *queryGraphQLServer) GetNodesByType(ctx context.Context, typeArg string) ([]*core_gql.Node, error) {
	nodes, err := r.db.GetAllRegisteredNodes(ctx)
	if err != nil {
		return nil, err
	}

	result := []*core_gql.Node{}
	for _, node := range nodes {
		if node.NodeType == typeArg {
			result = append(result, &core_gql.Node{
				Address:      node.CometAddress,
				Endpoint:     node.Endpoint,
				EthAddress:   node.EthAddress,
				CometAddress: node.CometAddress,
				CometPubKey:  &node.CometPubKey,
				NodeType:     node.NodeType,
				SpID:         &node.SpID,
			})
		}
	}
	return result, nil
}

func (r *queryGraphQLServer) GetStorageProofs(ctx context.Context, startBlock int, endBlock int, address *string) ([]*core_gql.StorageProof, error) {
	params := db.GetStorageProofsForNodeInRangeParams{
		BlockHeight:   int64(startBlock),
		BlockHeight_2: int64(endBlock),
	}
	if address != nil {
		params.Address = *address
	}

	proofs, err := r.db.GetStorageProofsForNodeInRange(ctx, params)
	if err != nil {
		return nil, err
	}

	result := []*core_gql.StorageProof{}
	for _, proof := range proofs {
		var proofSig *string
		if proof.ProofSignature.Valid {
			s := proof.ProofSignature.String
			proofSig = &s
		}

		result = append(result, &core_gql.StorageProof{
			BlockHeight:    int(proof.BlockHeight),
			ProverAddress:  proof.Address,
			Cid:            proof.Cid.String,
			Status:         string(proof.Status),
			ProofSignature: proofSig,
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetStorageProofsByBlock(ctx context.Context, height int) ([]*core_gql.StorageProof, error) {
	params := db.GetStorageProofsForNodeInRangeParams{
		BlockHeight:   int64(height),
		BlockHeight_2: int64(height),
	}

	proofs, err := r.db.GetStorageProofsForNodeInRange(ctx, params)
	if err != nil {
		return nil, err
	}

	result := []*core_gql.StorageProof{}
	for _, proof := range proofs {
		var proofSig *string
		if proof.ProofSignature.Valid {
			s := proof.ProofSignature.String
			proofSig = &s
		}

		result = append(result, &core_gql.StorageProof{
			BlockHeight:    int(proof.BlockHeight),
			ProverAddress:  proof.Address,
			Cid:            proof.Cid.String,
			Status:         string(proof.Status),
			ProofSignature: proofSig,
		})
	}
	return result, nil
}

func (r *queryGraphQLServer) GetLatestSLARollup(ctx context.Context) (*core_gql.SLARollup, error) {
	rollup, err := r.db.GetLatestSlaRollup(ctx)
	if err != nil {
		return nil, err
	}

	id := pgtype.Int4{Int32: rollup.ID, Valid: true}
	reports, err := r.db.GetRollupReportsForId(ctx, id)
	if err != nil {
		return nil, err
	}

	nodeReports := []*core_gql.SLANodeReport{}
	for _, report := range reports {
		nodeReports = append(nodeReports, &core_gql.SLANodeReport{
			Address:             report.Address,
			BlocksProposed:      int(report.BlocksProposed),
			Quota:               0, // TODO: Implement quota calculation
			PosChallengesFailed: 0, // TODO: Implement PoS challenge stats
			PosChallengesTotal:  0, // TODO: Implement PoS challenge stats
		})
	}

	return &core_gql.SLARollup{
		ID:          int(rollup.ID),
		TxHash:      rollup.TxHash,
		BlockStart:  int(rollup.BlockStart),
		BlockEnd:    int(rollup.BlockEnd),
		Timestamp:   rollup.Time.Time.String(),
		NodeReports: nodeReports,
	}, nil
}

func (r *queryGraphQLServer) GetSLARollup(ctx context.Context, id int) (*core_gql.SLARollup, error) {
	rollup, err := r.db.GetSlaRollupWithId(ctx, int32(id))
	if err != nil {
		return nil, err
	}

	rollupId := pgtype.Int4{Int32: rollup.ID, Valid: true}
	reports, err := r.db.GetRollupReportsForId(ctx, rollupId)
	if err != nil {
		return nil, err
	}

	nodeReports := []*core_gql.SLANodeReport{}
	for _, report := range reports {
		nodeReports = append(nodeReports, &core_gql.SLANodeReport{
			Address:             report.Address,
			BlocksProposed:      int(report.BlocksProposed),
			Quota:               0, // TODO: Implement quota calculation
			PosChallengesFailed: 0, // TODO: Implement PoS challenge stats
			PosChallengesTotal:  0, // TODO: Implement PoS challenge stats
		})
	}

	return &core_gql.SLARollup{
		ID:          int(rollup.ID),
		TxHash:      rollup.TxHash,
		BlockStart:  int(rollup.BlockStart),
		BlockEnd:    int(rollup.BlockEnd),
		Timestamp:   rollup.Time.Time.String(),
		NodeReports: nodeReports,
	}, nil
}

func (r *queryGraphQLServer) GetNodeUptime(ctx context.Context, address string, rollupID *int) (*core_gql.NodeUptime, error) {
	// Get the node first
	nodes, err := r.db.GetAllRegisteredNodes(ctx)
	if err != nil {
		return nil, err
	}

	var node *db.CoreValidator
	for _, n := range nodes {
		if n.CometAddress == address {
			node = &n
			break
		}
	}
	if node == nil {
		return nil, fmt.Errorf("node not found")
	}

	// Get rollup
	var rollup db.SlaRollup
	if rollupID != nil {
		rollup, err = r.db.GetSlaRollupWithId(ctx, int32(*rollupID))
	} else {
		rollup, err = r.db.GetLatestSlaRollup(ctx)
	}
	if err != nil {
		return nil, err
	}

	// Get report for this node
	params := db.GetRollupReportForNodeAndIdParams{
		Address:     address,
		SlaRollupID: pgtype.Int4{Int32: rollup.ID, Valid: true},
	}
	report, err := r.db.GetRollupReportForNodeAndId(ctx, params)
	if err != nil {
		// If no report found, create empty one
		report = db.SlaNodeReport{
			Address:        address,
			BlocksProposed: 0,
		}
	}

	return &core_gql.NodeUptime{
		Address:     address,
		Endpoint:    &node.Endpoint,
		IsValidator: node.NodeType == "validator",
		ActiveReport: &core_gql.SLAReport{
			RollupID:            int(rollup.ID),
			TxHash:              rollup.TxHash,
			BlockStart:          int(rollup.BlockStart),
			BlockEnd:            int(rollup.BlockEnd),
			BlocksProposed:      int(report.BlocksProposed),
			Quota:               0, // TODO: Implement quota calculation
			PosChallengesFailed: 0, // TODO: Implement PoS challenge stats
			PosChallengesTotal:  0, // TODO: Implement PoS challenge stats
			Timestamp:           rollup.Time.Time.String(),
		},
		ReportHistory: []*core_gql.SLAReport{}, // TODO: Implement historical reports
	}, nil
}

func (r *queryGraphQLServer) GetAllValidatorUptimes(ctx context.Context, rollupID *int) ([]*core_gql.NodeUptime, error) {
	// Get all nodes first
	nodes, err := r.db.GetAllRegisteredNodes(ctx)
	if err != nil {
		return nil, err
	}

	// Get latest rollup if no ID specified
	var rollup db.SlaRollup
	if rollupID != nil {
		rollup, err = r.db.GetSlaRollupWithId(ctx, int32(*rollupID))
	} else {
		rollup, err = r.db.GetLatestSlaRollup(ctx)
	}
	if err != nil {
		return nil, err
	}

	// Get reports for this rollup
	rollupIdParam := pgtype.Int4{Int32: rollup.ID, Valid: true}
	reports, err := r.db.GetRollupReportsForId(ctx, rollupIdParam)
	if err != nil {
		return nil, err
	}

	// Build map of reports by address
	reportsByAddress := make(map[string]db.SlaNodeReport)
	for _, report := range reports {
		reportsByAddress[report.Address] = report
	}

	result := []*core_gql.NodeUptime{}
	for _, node := range nodes {
		if node.NodeType != "validator" {
			continue
		}

		report, hasReport := reportsByAddress[node.CometAddress]
		if !hasReport {
			// Node has no report for this period
			report = db.SlaNodeReport{
				Address:        node.CometAddress,
				BlocksProposed: 0,
			}
		}

		result = append(result, &core_gql.NodeUptime{
			Address:     node.CometAddress,
			Endpoint:    &node.Endpoint,
			IsValidator: true,
			ActiveReport: &core_gql.SLAReport{
				RollupID:            int(rollup.ID),
				TxHash:              rollup.TxHash,
				BlockStart:          int(rollup.BlockStart),
				BlockEnd:            int(rollup.BlockEnd),
				BlocksProposed:      int(report.BlocksProposed),
				Quota:               0, // TODO: Implement quota calculation
				PosChallengesFailed: 0, // TODO: Implement PoS challenge stats
				PosChallengesTotal:  0, // TODO: Implement PoS challenge stats
				Timestamp:           rollup.Time.Time.String(),
			},
			ReportHistory: []*core_gql.SLAReport{}, // TODO: Implement historical reports
		})
	}

	return result, nil
}

func (r *GraphQLServer) Query() core_gql.QueryResolver { return &queryGraphQLServer{r} }

type queryGraphQLServer struct{ *GraphQLServer }
