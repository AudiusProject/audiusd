// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reads.sql

package db

import (
	"context"
)

const getCountOfEndpointsWithDelegateWallet = `-- name: GetCountOfEndpointsWithDelegateWallet :one
select count(*) from eth_registered_endpoints
where delegate_wallet = $1
`

func (q *Queries) GetCountOfEndpointsWithDelegateWallet(ctx context.Context, delegateWallet string) (int64, error) {
	row := q.db.QueryRow(ctx, getCountOfEndpointsWithDelegateWallet, delegateWallet)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLatestFundingRound = `-- name: GetLatestFundingRound :one
select round_num, blocknumber, creation_time from eth_funding_rounds order by round_num desc limit 1
`

func (q *Queries) GetLatestFundingRound(ctx context.Context) (EthFundingRound, error) {
	row := q.db.QueryRow(ctx, getLatestFundingRound)
	var i EthFundingRound
	err := row.Scan(&i.RoundNum, &i.Blocknumber, &i.CreationTime)
	return i, err
}

const getRegisteredEndpoint = `-- name: GetRegisteredEndpoint :one
select id, service_type, owner, delegate_wallet, endpoint, blocknumber from eth_registered_endpoints
where delegate_wallet = $1 and endpoint = $2
`

type GetRegisteredEndpointParams struct {
	DelegateWallet string `json:"delegate_wallet"`
	Endpoint       string `json:"endpoint"`
}

func (q *Queries) GetRegisteredEndpoint(ctx context.Context, arg GetRegisteredEndpointParams) (EthRegisteredEndpoint, error) {
	row := q.db.QueryRow(ctx, getRegisteredEndpoint, arg.DelegateWallet, arg.Endpoint)
	var i EthRegisteredEndpoint
	err := row.Scan(
		&i.ID,
		&i.ServiceType,
		&i.Owner,
		&i.DelegateWallet,
		&i.Endpoint,
		&i.Blocknumber,
	)
	return i, err
}

const getRegisteredEndpoints = `-- name: GetRegisteredEndpoints :many
select id, service_type, owner, delegate_wallet, endpoint, blocknumber from eth_registered_endpoints
`

func (q *Queries) GetRegisteredEndpoints(ctx context.Context) ([]EthRegisteredEndpoint, error) {
	rows, err := q.db.Query(ctx, getRegisteredEndpoints)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EthRegisteredEndpoint
	for rows.Next() {
		var i EthRegisteredEndpoint
		if err := rows.Scan(
			&i.ID,
			&i.ServiceType,
			&i.Owner,
			&i.DelegateWallet,
			&i.Endpoint,
			&i.Blocknumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProviders = `-- name: GetServiceProviders :many
select address, deployer_stake, deployer_cut, valid_bounds, number_of_endpoints, min_account_stake, max_account_stake from eth_service_providers
`

func (q *Queries) GetServiceProviders(ctx context.Context) ([]EthServiceProvider, error) {
	rows, err := q.db.Query(ctx, getServiceProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EthServiceProvider
	for rows.Next() {
		var i EthServiceProvider
		if err := rows.Scan(
			&i.Address,
			&i.DeployerStake,
			&i.DeployerCut,
			&i.ValidBounds,
			&i.NumberOfEndpoints,
			&i.MinAccountStake,
			&i.MaxAccountStake,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
