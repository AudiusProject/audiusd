// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reads.sql

package db

import (
	"context"
)

const getCountOfEndpointsWithDelegateWallet = `-- name: GetCountOfEndpointsWithDelegateWallet :one
select count(*) from eth_registered_endpoints
where delegate_wallet = $1
`

func (q *Queries) GetCountOfEndpointsWithDelegateWallet(ctx context.Context, delegateWallet string) (int64, error) {
	row := q.db.QueryRow(ctx, getCountOfEndpointsWithDelegateWallet, delegateWallet)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLatestFundingRound = `-- name: GetLatestFundingRound :one
select round_num, blocknumber, creation_time from eth_funding_rounds order by round_num desc limit 1
`

func (q *Queries) GetLatestFundingRound(ctx context.Context) (EthFundingRound, error) {
	row := q.db.QueryRow(ctx, getLatestFundingRound)
	var i EthFundingRound
	err := row.Scan(&i.RoundNum, &i.Blocknumber, &i.CreationTime)
	return i, err
}

const getRegisteredEndpoint = `-- name: GetRegisteredEndpoint :one
select id, service_type, owner, delegate_wallet, endpoint, blocknumber, registered_at from eth_registered_endpoints
where endpoint = $1
`

func (q *Queries) GetRegisteredEndpoint(ctx context.Context, endpoint string) (EthRegisteredEndpoint, error) {
	row := q.db.QueryRow(ctx, getRegisteredEndpoint, endpoint)
	var i EthRegisteredEndpoint
	err := row.Scan(
		&i.ID,
		&i.ServiceType,
		&i.Owner,
		&i.DelegateWallet,
		&i.Endpoint,
		&i.Blocknumber,
		&i.RegisteredAt,
	)
	return i, err
}

const getRegisteredEndpoints = `-- name: GetRegisteredEndpoints :many
select id, service_type, owner, delegate_wallet, endpoint, blocknumber, registered_at from eth_registered_endpoints
`

func (q *Queries) GetRegisteredEndpoints(ctx context.Context) ([]EthRegisteredEndpoint, error) {
	rows, err := q.db.Query(ctx, getRegisteredEndpoints)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EthRegisteredEndpoint
	for rows.Next() {
		var i EthRegisteredEndpoint
		if err := rows.Scan(
			&i.ID,
			&i.ServiceType,
			&i.Owner,
			&i.DelegateWallet,
			&i.Endpoint,
			&i.Blocknumber,
			&i.RegisteredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegisteredEndpointsForServiceProvider = `-- name: GetRegisteredEndpointsForServiceProvider :many
select id, service_type, owner, delegate_wallet, endpoint, blocknumber, registered_at from eth_registered_endpoints
where owner = $1
`

func (q *Queries) GetRegisteredEndpointsForServiceProvider(ctx context.Context, owner string) ([]EthRegisteredEndpoint, error) {
	rows, err := q.db.Query(ctx, getRegisteredEndpointsForServiceProvider, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EthRegisteredEndpoint
	for rows.Next() {
		var i EthRegisteredEndpoint
		if err := rows.Scan(
			&i.ID,
			&i.ServiceType,
			&i.Owner,
			&i.DelegateWallet,
			&i.Endpoint,
			&i.Blocknumber,
			&i.RegisteredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProvider = `-- name: GetServiceProvider :one
select address, deployer_stake, deployer_cut, valid_bounds, number_of_endpoints, min_account_stake, max_account_stake from eth_service_providers
where address = $1
`

func (q *Queries) GetServiceProvider(ctx context.Context, address string) (EthServiceProvider, error) {
	row := q.db.QueryRow(ctx, getServiceProvider, address)
	var i EthServiceProvider
	err := row.Scan(
		&i.Address,
		&i.DeployerStake,
		&i.DeployerCut,
		&i.ValidBounds,
		&i.NumberOfEndpoints,
		&i.MinAccountStake,
		&i.MaxAccountStake,
	)
	return i, err
}

const getServiceProviders = `-- name: GetServiceProviders :many
select address, deployer_stake, deployer_cut, valid_bounds, number_of_endpoints, min_account_stake, max_account_stake from eth_service_providers
`

func (q *Queries) GetServiceProviders(ctx context.Context) ([]EthServiceProvider, error) {
	rows, err := q.db.Query(ctx, getServiceProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EthServiceProvider
	for rows.Next() {
		var i EthServiceProvider
		if err := rows.Scan(
			&i.Address,
			&i.DeployerStake,
			&i.DeployerCut,
			&i.ValidBounds,
			&i.NumberOfEndpoints,
			&i.MinAccountStake,
			&i.MaxAccountStake,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStakedAmountForServiceProvider = `-- name: GetStakedAmountForServiceProvider :one
select total_staked from eth_staked where address = $1
`

func (q *Queries) GetStakedAmountForServiceProvider(ctx context.Context, address string) (int64, error) {
	row := q.db.QueryRow(ctx, getStakedAmountForServiceProvider, address)
	var total_staked int64
	err := row.Scan(&total_staked)
	return total_staked, err
}
