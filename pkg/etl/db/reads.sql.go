// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reads.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getBlockRangeFirst = `-- name: GetBlockRangeFirst :one
select id, proposer_address, block_height, block_time 
from etl_blocks
where block_time >= $1 and block_time <= $2
order by block_time
limit 1
`

type GetBlockRangeFirstParams struct {
	BlockTime   pgtype.Timestamp `json:"block_time"`
	BlockTime_2 pgtype.Timestamp `json:"block_time_2"`
}

func (q *Queries) GetBlockRangeFirst(ctx context.Context, arg GetBlockRangeFirstParams) (EtlBlock, error) {
	row := q.db.QueryRow(ctx, getBlockRangeFirst, arg.BlockTime, arg.BlockTime_2)
	var i EtlBlock
	err := row.Scan(
		&i.ID,
		&i.ProposerAddress,
		&i.BlockHeight,
		&i.BlockTime,
	)
	return i, err
}

const getBlockRangeLast = `-- name: GetBlockRangeLast :one
select id, proposer_address, block_height, block_time 
from etl_blocks
where block_time >= $1 and block_time <= $2
order by block_time desc
limit 1
`

type GetBlockRangeLastParams struct {
	BlockTime   pgtype.Timestamp `json:"block_time"`
	BlockTime_2 pgtype.Timestamp `json:"block_time_2"`
}

func (q *Queries) GetBlockRangeLast(ctx context.Context, arg GetBlockRangeLastParams) (EtlBlock, error) {
	row := q.db.QueryRow(ctx, getBlockRangeLast, arg.BlockTime, arg.BlockTime_2)
	var i EtlBlock
	err := row.Scan(
		&i.ID,
		&i.ProposerAddress,
		&i.BlockHeight,
		&i.BlockTime,
	)
	return i, err
}

const getLatestIndexedBlock = `-- name: GetLatestIndexedBlock :one

SELECT block_height
FROM etl_blocks
ORDER BY id DESC
LIMIT 1
`

// Normalized read queries for ETL database
// Uses the new schema with proper JOIN operations for efficiency
// get latest indexed block height
func (q *Queries) GetLatestIndexedBlock(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getLatestIndexedBlock)
	var block_height int64
	err := row.Scan(&block_height)
	return block_height, err
}

const getManageEntitiesByBlockHeightCursor = `-- name: GetManageEntitiesByBlockHeightCursor :many
select id, address, entity_type, entity_id, action, metadata, signature, signer, nonce, block_height, tx_hash, created_at from etl_manage_entities
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetManageEntitiesByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetManageEntitiesByBlockHeightCursor(ctx context.Context, arg GetManageEntitiesByBlockHeightCursorParams) ([]EtlManageEntity, error) {
	rows, err := q.db.Query(ctx, getManageEntitiesByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlManageEntity
	for rows.Next() {
		var i EtlManageEntity
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.Metadata,
			&i.Signature,
			&i.Signer,
			&i.Nonce,
			&i.BlockHeight,
			&i.TxHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaysByBlockHeightCursor = `-- name: GetPlaysByBlockHeightCursor :many
select id, user_id, track_id, city, region, country, played_at, block_height, tx_hash, listened_at, recorded_at from etl_plays
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetPlaysByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetPlaysByBlockHeightCursor(ctx context.Context, arg GetPlaysByBlockHeightCursorParams) ([]EtlPlay, error) {
	rows, err := q.db.Query(ctx, getPlaysByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlPlay
	for rows.Next() {
		var i EtlPlay
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TrackID,
			&i.City,
			&i.Region,
			&i.Country,
			&i.PlayedAt,
			&i.BlockHeight,
			&i.TxHash,
			&i.ListenedAt,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlaNodeReportsByBlockHeightCursor = `-- name: GetSlaNodeReportsByBlockHeightCursor :many
select id, sla_rollup_id, address, num_blocks_proposed, challenges_received, challenges_failed, block_height, tx_hash, created_at from etl_sla_node_reports
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetSlaNodeReportsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetSlaNodeReportsByBlockHeightCursor(ctx context.Context, arg GetSlaNodeReportsByBlockHeightCursorParams) ([]EtlSlaNodeReport, error) {
	rows, err := q.db.Query(ctx, getSlaNodeReportsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlSlaNodeReport
	for rows.Next() {
		var i EtlSlaNodeReport
		if err := rows.Scan(
			&i.ID,
			&i.SlaRollupID,
			&i.Address,
			&i.NumBlocksProposed,
			&i.ChallengesReceived,
			&i.ChallengesFailed,
			&i.BlockHeight,
			&i.TxHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlaRollupsByBlockHeightCursor = `-- name: GetSlaRollupsByBlockHeightCursor :many
select id, block_start, block_end, block_height, validator_count, block_quota, tx_hash, created_at from etl_sla_rollups
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetSlaRollupsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetSlaRollupsByBlockHeightCursor(ctx context.Context, arg GetSlaRollupsByBlockHeightCursorParams) ([]EtlSlaRollup, error) {
	rows, err := q.db.Query(ctx, getSlaRollupsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlSlaRollup
	for rows.Next() {
		var i EtlSlaRollup
		if err := rows.Scan(
			&i.ID,
			&i.BlockStart,
			&i.BlockEnd,
			&i.BlockHeight,
			&i.ValidatorCount,
			&i.BlockQuota,
			&i.TxHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStorageProofVerificationsByBlockHeightCursor = `-- name: GetStorageProofVerificationsByBlockHeightCursor :many
select id, height, proof, block_height, tx_hash, created_at from etl_storage_proof_verifications
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetStorageProofVerificationsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetStorageProofVerificationsByBlockHeightCursor(ctx context.Context, arg GetStorageProofVerificationsByBlockHeightCursorParams) ([]EtlStorageProofVerification, error) {
	rows, err := q.db.Query(ctx, getStorageProofVerificationsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlStorageProofVerification
	for rows.Next() {
		var i EtlStorageProofVerification
		if err := rows.Scan(
			&i.ID,
			&i.Height,
			&i.Proof,
			&i.BlockHeight,
			&i.TxHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStorageProofsByBlockHeightCursor = `-- name: GetStorageProofsByBlockHeightCursor :many
select id, height, address, prover_addresses, cid, proof_signature, block_height, tx_hash, created_at from etl_storage_proofs
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetStorageProofsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetStorageProofsByBlockHeightCursor(ctx context.Context, arg GetStorageProofsByBlockHeightCursorParams) ([]EtlStorageProof, error) {
	rows, err := q.db.Query(ctx, getStorageProofsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlStorageProof
	for rows.Next() {
		var i EtlStorageProof
		if err := rows.Scan(
			&i.ID,
			&i.Height,
			&i.Address,
			&i.ProverAddresses,
			&i.Cid,
			&i.ProofSignature,
			&i.BlockHeight,
			&i.TxHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByBlockHeightCursor = `-- name: GetTransactionsByBlockHeightCursor :many
select id, tx_hash, block_height, tx_index, tx_type, created_at from etl_transactions
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetTransactionsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetTransactionsByBlockHeightCursor(ctx context.Context, arg GetTransactionsByBlockHeightCursorParams) ([]EtlTransaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlTransaction
	for rows.Next() {
		var i EtlTransaction
		if err := rows.Scan(
			&i.ID,
			&i.TxHash,
			&i.BlockHeight,
			&i.TxIndex,
			&i.TxType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidatorDeregistrationsByBlockHeightCursor = `-- name: GetValidatorDeregistrationsByBlockHeightCursor :many
select id, comet_address, comet_pubkey, block_height, tx_hash from etl_validator_deregistrations
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetValidatorDeregistrationsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetValidatorDeregistrationsByBlockHeightCursor(ctx context.Context, arg GetValidatorDeregistrationsByBlockHeightCursorParams) ([]EtlValidatorDeregistration, error) {
	rows, err := q.db.Query(ctx, getValidatorDeregistrationsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlValidatorDeregistration
	for rows.Next() {
		var i EtlValidatorDeregistration
		if err := rows.Scan(
			&i.ID,
			&i.CometAddress,
			&i.CometPubkey,
			&i.BlockHeight,
			&i.TxHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidatorMisbehaviorDeregistrationsByBlockHeightCursor = `-- name: GetValidatorMisbehaviorDeregistrationsByBlockHeightCursor :many
select id, comet_address, pub_key, block_height, tx_hash, created_at from etl_validator_misbehavior_deregistrations
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetValidatorMisbehaviorDeregistrationsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetValidatorMisbehaviorDeregistrationsByBlockHeightCursor(ctx context.Context, arg GetValidatorMisbehaviorDeregistrationsByBlockHeightCursorParams) ([]EtlValidatorMisbehaviorDeregistration, error) {
	rows, err := q.db.Query(ctx, getValidatorMisbehaviorDeregistrationsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlValidatorMisbehaviorDeregistration
	for rows.Next() {
		var i EtlValidatorMisbehaviorDeregistration
		if err := rows.Scan(
			&i.ID,
			&i.CometAddress,
			&i.PubKey,
			&i.BlockHeight,
			&i.TxHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidatorRegistrationsByBlockHeightCursor = `-- name: GetValidatorRegistrationsByBlockHeightCursor :many
select id, address, endpoint, comet_address, eth_block, node_type, spid, comet_pubkey, voting_power, block_height, tx_hash from etl_validator_registrations
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetValidatorRegistrationsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetValidatorRegistrationsByBlockHeightCursor(ctx context.Context, arg GetValidatorRegistrationsByBlockHeightCursorParams) ([]EtlValidatorRegistration, error) {
	rows, err := q.db.Query(ctx, getValidatorRegistrationsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlValidatorRegistration
	for rows.Next() {
		var i EtlValidatorRegistration
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Endpoint,
			&i.CometAddress,
			&i.EthBlock,
			&i.NodeType,
			&i.Spid,
			&i.CometPubkey,
			&i.VotingPower,
			&i.BlockHeight,
			&i.TxHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
