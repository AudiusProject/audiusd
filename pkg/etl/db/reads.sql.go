// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reads.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getLatestIndexedBlock = `-- name: GetLatestIndexedBlock :one
select block_height 
from etl_latest_indexed_block 
order by id desc 
limit 1
`

// get latest indexed block height
func (q *Queries) GetLatestIndexedBlock(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getLatestIndexedBlock)
	var block_height int64
	err := row.Scan(&block_height)
	return block_height, err
}

const getPlayCountByAddress = `-- name: GetPlayCountByAddress :one
select count(*) as play_count 
from etl_plays 
where address = $1
`

// get play count by address
func (q *Queries) GetPlayCountByAddress(ctx context.Context, address string) (int64, error) {
	row := q.db.QueryRow(ctx, getPlayCountByAddress, address)
	var play_count int64
	err := row.Scan(&play_count)
	return play_count, err
}

const getPlayCountByTrack = `-- name: GetPlayCountByTrack :one
select count(*) as play_count 
from etl_plays 
where track_id = $1
`

// get play count by track
func (q *Queries) GetPlayCountByTrack(ctx context.Context, trackID string) (int64, error) {
	row := q.db.QueryRow(ctx, getPlayCountByTrack, trackID)
	var play_count int64
	err := row.Scan(&play_count)
	return play_count, err
}

const getPlays = `-- name: GetPlays :many
select 
    address,
    track_id,
    extract(epoch from played_at)::bigint as timestamp,
    city,
    country,
    region,
    block_height,
    tx_hash
from etl_plays
where 
    ($1::text is null or address = $1)
    and ($2::text is null or track_id = $2)
    and ($3::timestamp is null or $4::timestamp is null or played_at between $3 and $4)
order by 
    case 
        when $5 = 'played_at' and $6 = 'asc' then played_at
        when $5 = 'block_height' and $6 = 'asc' then block_height
    end asc nulls last,
    case 
        when $5 = 'played_at' and $6 = 'desc' then played_at
        when $5 = 'block_height' and $6 = 'desc' then block_height
    end desc nulls last
limit $7 offset $8
`

type GetPlaysParams struct {
	Column1 string
	Column2 string
	Column3 pgtype.Timestamp
	Column4 pgtype.Timestamp
	Column5 interface{}
	Column6 interface{}
	Limit   int32
	Offset  int32
}

type GetPlaysRow struct {
	Address     string
	TrackID     string
	Timestamp   int64
	City        string
	Country     string
	Region      string
	BlockHeight int64
	TxHash      string
}

// get plays with filtering, pagination, and ordering
func (q *Queries) GetPlays(ctx context.Context, arg GetPlaysParams) ([]GetPlaysRow, error) {
	rows, err := q.db.Query(ctx, getPlays,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaysRow
	for rows.Next() {
		var i GetPlaysRow
		if err := rows.Scan(
			&i.Address,
			&i.TrackID,
			&i.Timestamp,
			&i.City,
			&i.Country,
			&i.Region,
			&i.BlockHeight,
			&i.TxHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaysCount = `-- name: GetPlaysCount :one
select count(*) as total
from etl_plays
where 
    ($1::text is null or address = $1)
    and ($2::text is null or track_id = $2)
    and ($3::timestamp is null or $4::timestamp is null or played_at between $3 and $4)
`

type GetPlaysCountParams struct {
	Column1 string
	Column2 string
	Column3 pgtype.Timestamp
	Column4 pgtype.Timestamp
}

// get total count of plays with filtering
func (q *Queries) GetPlaysCount(ctx context.Context, arg GetPlaysCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getPlaysCount,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}
