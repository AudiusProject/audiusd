// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reads.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getActiveValidators = `-- name: GetActiveValidators :many
select id, address, endpoint, comet_address, node_type, spid, voting_power, status, registered_at, deregistered_at, created_at, updated_at from etl_validators
where status = 'active'
order by voting_power desc
limit $1 offset $2
`

type GetActiveValidatorsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetActiveValidators(ctx context.Context, arg GetActiveValidatorsParams) ([]EtlValidator, error) {
	rows, err := q.db.Query(ctx, getActiveValidators, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlValidator
	for rows.Next() {
		var i EtlValidator
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Endpoint,
			&i.CometAddress,
			&i.NodeType,
			&i.Spid,
			&i.VotingPower,
			&i.Status,
			&i.RegisteredAt,
			&i.DeregisteredAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockByHeight = `-- name: GetBlockByHeight :one
select id, proposer_address, block_height, block_time from etl_blocks
where block_height = $1
`

func (q *Queries) GetBlockByHeight(ctx context.Context, blockHeight int64) (EtlBlock, error) {
	row := q.db.QueryRow(ctx, getBlockByHeight, blockHeight)
	var i EtlBlock
	err := row.Scan(
		&i.ID,
		&i.ProposerAddress,
		&i.BlockHeight,
		&i.BlockTime,
	)
	return i, err
}

const getBlockRangeFirst = `-- name: GetBlockRangeFirst :one
select id, proposer_address, block_height, block_time 
from etl_blocks
where block_time >= $1 and block_time <= $2
order by block_time
limit 1
`

type GetBlockRangeFirstParams struct {
	BlockTime   pgtype.Timestamp `json:"block_time"`
	BlockTime_2 pgtype.Timestamp `json:"block_time_2"`
}

func (q *Queries) GetBlockRangeFirst(ctx context.Context, arg GetBlockRangeFirstParams) (EtlBlock, error) {
	row := q.db.QueryRow(ctx, getBlockRangeFirst, arg.BlockTime, arg.BlockTime_2)
	var i EtlBlock
	err := row.Scan(
		&i.ID,
		&i.ProposerAddress,
		&i.BlockHeight,
		&i.BlockTime,
	)
	return i, err
}

const getBlockRangeLast = `-- name: GetBlockRangeLast :one
select id, proposer_address, block_height, block_time 
from etl_blocks
where block_time >= $1 and block_time <= $2
order by block_time desc
limit 1
`

type GetBlockRangeLastParams struct {
	BlockTime   pgtype.Timestamp `json:"block_time"`
	BlockTime_2 pgtype.Timestamp `json:"block_time_2"`
}

func (q *Queries) GetBlockRangeLast(ctx context.Context, arg GetBlockRangeLastParams) (EtlBlock, error) {
	row := q.db.QueryRow(ctx, getBlockRangeLast, arg.BlockTime, arg.BlockTime_2)
	var i EtlBlock
	err := row.Scan(
		&i.ID,
		&i.ProposerAddress,
		&i.BlockHeight,
		&i.BlockTime,
	)
	return i, err
}

const getBlockTransactionCount = `-- name: GetBlockTransactionCount :one
select count(*) from etl_transactions
where block_height = $1
`

func (q *Queries) GetBlockTransactionCount(ctx context.Context, blockHeight int64) (int64, error) {
	row := q.db.QueryRow(ctx, getBlockTransactionCount, blockHeight)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getBlocksByPage = `-- name: GetBlocksByPage :many
select id, proposer_address, block_height, block_time from etl_blocks
order by block_height desc
limit $1 offset $2
`

type GetBlocksByPageParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetBlocksByPage(ctx context.Context, arg GetBlocksByPageParams) ([]EtlBlock, error) {
	rows, err := q.db.Query(ctx, getBlocksByPage, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlBlock
	for rows.Next() {
		var i EtlBlock
		if err := rows.Scan(
			&i.ID,
			&i.ProposerAddress,
			&i.BlockHeight,
			&i.BlockTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestIndexedBlock = `-- name: GetLatestIndexedBlock :one
SELECT block_height
FROM etl_blocks
ORDER BY id DESC
LIMIT 1
`

// get latest indexed block height
func (q *Queries) GetLatestIndexedBlock(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getLatestIndexedBlock)
	var block_height int64
	err := row.Scan(&block_height)
	return block_height, err
}

const getManageEntitiesByBlockHeightCursor = `-- name: GetManageEntitiesByBlockHeightCursor :many
select id, address, entity_type, entity_id, action, metadata, signature, signer, nonce, block_height, tx_hash, created_at from etl_manage_entities
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetManageEntitiesByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetManageEntitiesByBlockHeightCursor(ctx context.Context, arg GetManageEntitiesByBlockHeightCursorParams) ([]EtlManageEntity, error) {
	rows, err := q.db.Query(ctx, getManageEntitiesByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlManageEntity
	for rows.Next() {
		var i EtlManageEntity
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.Metadata,
			&i.Signature,
			&i.Signer,
			&i.Nonce,
			&i.BlockHeight,
			&i.TxHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaysByBlockHeightCursor = `-- name: GetPlaysByBlockHeightCursor :many
select id, user_id, track_id, city, region, country, played_at, block_height, tx_hash, listened_at, recorded_at from etl_plays
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetPlaysByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetPlaysByBlockHeightCursor(ctx context.Context, arg GetPlaysByBlockHeightCursorParams) ([]EtlPlay, error) {
	rows, err := q.db.Query(ctx, getPlaysByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlPlay
	for rows.Next() {
		var i EtlPlay
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TrackID,
			&i.City,
			&i.Region,
			&i.Country,
			&i.PlayedAt,
			&i.BlockHeight,
			&i.TxHash,
			&i.ListenedAt,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlaNodeReportsByAddress = `-- name: GetSlaNodeReportsByAddress :many
select id, sla_rollup_id, address, num_blocks_proposed, challenges_received, challenges_failed, block_height, tx_hash, created_at from etl_sla_node_reports
where address = $1
order by block_height desc
limit $2
`

type GetSlaNodeReportsByAddressParams struct {
	Address string `json:"address"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) GetSlaNodeReportsByAddress(ctx context.Context, arg GetSlaNodeReportsByAddressParams) ([]EtlSlaNodeReport, error) {
	rows, err := q.db.Query(ctx, getSlaNodeReportsByAddress, arg.Address, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlSlaNodeReport
	for rows.Next() {
		var i EtlSlaNodeReport
		if err := rows.Scan(
			&i.ID,
			&i.SlaRollupID,
			&i.Address,
			&i.NumBlocksProposed,
			&i.ChallengesReceived,
			&i.ChallengesFailed,
			&i.BlockHeight,
			&i.TxHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlaNodeReportsByBlockHeightCursor = `-- name: GetSlaNodeReportsByBlockHeightCursor :many
select id, sla_rollup_id, address, num_blocks_proposed, challenges_received, challenges_failed, block_height, tx_hash, created_at from etl_sla_node_reports
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetSlaNodeReportsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetSlaNodeReportsByBlockHeightCursor(ctx context.Context, arg GetSlaNodeReportsByBlockHeightCursorParams) ([]EtlSlaNodeReport, error) {
	rows, err := q.db.Query(ctx, getSlaNodeReportsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlSlaNodeReport
	for rows.Next() {
		var i EtlSlaNodeReport
		if err := rows.Scan(
			&i.ID,
			&i.SlaRollupID,
			&i.Address,
			&i.NumBlocksProposed,
			&i.ChallengesReceived,
			&i.ChallengesFailed,
			&i.BlockHeight,
			&i.TxHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlaRollupsByBlockHeightCursor = `-- name: GetSlaRollupsByBlockHeightCursor :many
select id, block_start, block_end, block_height, validator_count, block_quota, tx_hash, created_at from etl_sla_rollups
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetSlaRollupsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetSlaRollupsByBlockHeightCursor(ctx context.Context, arg GetSlaRollupsByBlockHeightCursorParams) ([]EtlSlaRollup, error) {
	rows, err := q.db.Query(ctx, getSlaRollupsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlSlaRollup
	for rows.Next() {
		var i EtlSlaRollup
		if err := rows.Scan(
			&i.ID,
			&i.BlockStart,
			&i.BlockEnd,
			&i.BlockHeight,
			&i.ValidatorCount,
			&i.BlockQuota,
			&i.TxHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStorageProofVerificationsByBlockHeightCursor = `-- name: GetStorageProofVerificationsByBlockHeightCursor :many
select id, height, proof, block_height, tx_hash, created_at from etl_storage_proof_verifications
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetStorageProofVerificationsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetStorageProofVerificationsByBlockHeightCursor(ctx context.Context, arg GetStorageProofVerificationsByBlockHeightCursorParams) ([]EtlStorageProofVerification, error) {
	rows, err := q.db.Query(ctx, getStorageProofVerificationsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlStorageProofVerification
	for rows.Next() {
		var i EtlStorageProofVerification
		if err := rows.Scan(
			&i.ID,
			&i.Height,
			&i.Proof,
			&i.BlockHeight,
			&i.TxHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStorageProofsByBlockHeightCursor = `-- name: GetStorageProofsByBlockHeightCursor :many
select id, height, address, prover_addresses, cid, proof_signature, block_height, tx_hash, created_at from etl_storage_proofs
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetStorageProofsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetStorageProofsByBlockHeightCursor(ctx context.Context, arg GetStorageProofsByBlockHeightCursorParams) ([]EtlStorageProof, error) {
	rows, err := q.db.Query(ctx, getStorageProofsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlStorageProof
	for rows.Next() {
		var i EtlStorageProof
		if err := rows.Scan(
			&i.ID,
			&i.Height,
			&i.Address,
			&i.ProverAddresses,
			&i.Cid,
			&i.ProofSignature,
			&i.BlockHeight,
			&i.TxHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalTransactions = `-- name: GetTotalTransactions :one
select id from etl_transactions order by id desc limit 1
`

func (q *Queries) GetTotalTransactions(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, getTotalTransactions)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getTransactionByHash = `-- name: GetTransactionByHash :one
select id, tx_hash, block_height, tx_index, tx_type, created_at from etl_transactions
where tx_hash = $1
`

func (q *Queries) GetTransactionByHash(ctx context.Context, txHash string) (EtlTransaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByHash, txHash)
	var i EtlTransaction
	err := row.Scan(
		&i.ID,
		&i.TxHash,
		&i.BlockHeight,
		&i.TxIndex,
		&i.TxType,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactionsByBlockHeightCursor = `-- name: GetTransactionsByBlockHeightCursor :many
select id, tx_hash, block_height, tx_index, tx_type, created_at from etl_transactions
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetTransactionsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetTransactionsByBlockHeightCursor(ctx context.Context, arg GetTransactionsByBlockHeightCursorParams) ([]EtlTransaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlTransaction
	for rows.Next() {
		var i EtlTransaction
		if err := rows.Scan(
			&i.ID,
			&i.TxHash,
			&i.BlockHeight,
			&i.TxIndex,
			&i.TxType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByPage = `-- name: GetTransactionsByPage :many
select id, tx_hash, block_height, tx_index, tx_type, created_at from etl_transactions
order by block_height desc, tx_index desc
limit $1 offset $2
`

type GetTransactionsByPageParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetTransactionsByPage(ctx context.Context, arg GetTransactionsByPageParams) ([]EtlTransaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByPage, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlTransaction
	for rows.Next() {
		var i EtlTransaction
		if err := rows.Scan(
			&i.ID,
			&i.TxHash,
			&i.BlockHeight,
			&i.TxIndex,
			&i.TxType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidatorByAddress = `-- name: GetValidatorByAddress :one
select id, address, endpoint, comet_address, node_type, spid, voting_power, status, registered_at, deregistered_at, created_at, updated_at from etl_validators
where address = $1 or comet_address = $1
`

func (q *Queries) GetValidatorByAddress(ctx context.Context, address string) (EtlValidator, error) {
	row := q.db.QueryRow(ctx, getValidatorByAddress, address)
	var i EtlValidator
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Endpoint,
		&i.CometAddress,
		&i.NodeType,
		&i.Spid,
		&i.VotingPower,
		&i.Status,
		&i.RegisteredAt,
		&i.DeregisteredAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getValidatorCount = `-- name: GetValidatorCount :one
select count(*) from etl_validators
where status = 'active'
`

func (q *Queries) GetValidatorCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getValidatorCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getValidatorDeregistrations = `-- name: GetValidatorDeregistrations :many
select vd.id, vd.comet_address, vd.comet_pubkey, vd.block_height, vd.tx_hash, v.endpoint, v.node_type, v.spid, v.voting_power, v.status
from etl_validator_deregistrations vd
left join etl_validators v on v.comet_address = vd.comet_address
order by vd.block_height desc
limit $1 offset $2
`

type GetValidatorDeregistrationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetValidatorDeregistrationsRow struct {
	ID           int32       `json:"id"`
	CometAddress string      `json:"comet_address"`
	CometPubkey  []byte      `json:"comet_pubkey"`
	BlockHeight  int64       `json:"block_height"`
	TxHash       string      `json:"tx_hash"`
	Endpoint     pgtype.Text `json:"endpoint"`
	NodeType     pgtype.Text `json:"node_type"`
	Spid         pgtype.Text `json:"spid"`
	VotingPower  pgtype.Int8 `json:"voting_power"`
	Status       pgtype.Text `json:"status"`
}

func (q *Queries) GetValidatorDeregistrations(ctx context.Context, arg GetValidatorDeregistrationsParams) ([]GetValidatorDeregistrationsRow, error) {
	rows, err := q.db.Query(ctx, getValidatorDeregistrations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetValidatorDeregistrationsRow
	for rows.Next() {
		var i GetValidatorDeregistrationsRow
		if err := rows.Scan(
			&i.ID,
			&i.CometAddress,
			&i.CometPubkey,
			&i.BlockHeight,
			&i.TxHash,
			&i.Endpoint,
			&i.NodeType,
			&i.Spid,
			&i.VotingPower,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidatorDeregistrationsByBlockHeightCursor = `-- name: GetValidatorDeregistrationsByBlockHeightCursor :many
select id, comet_address, comet_pubkey, block_height, tx_hash from etl_validator_deregistrations
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetValidatorDeregistrationsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetValidatorDeregistrationsByBlockHeightCursor(ctx context.Context, arg GetValidatorDeregistrationsByBlockHeightCursorParams) ([]EtlValidatorDeregistration, error) {
	rows, err := q.db.Query(ctx, getValidatorDeregistrationsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlValidatorDeregistration
	for rows.Next() {
		var i EtlValidatorDeregistration
		if err := rows.Scan(
			&i.ID,
			&i.CometAddress,
			&i.CometPubkey,
			&i.BlockHeight,
			&i.TxHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidatorMisbehaviorDeregistrationsByBlockHeightCursor = `-- name: GetValidatorMisbehaviorDeregistrationsByBlockHeightCursor :many
select id, comet_address, pub_key, block_height, tx_hash, created_at from etl_validator_misbehavior_deregistrations
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetValidatorMisbehaviorDeregistrationsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetValidatorMisbehaviorDeregistrationsByBlockHeightCursor(ctx context.Context, arg GetValidatorMisbehaviorDeregistrationsByBlockHeightCursorParams) ([]EtlValidatorMisbehaviorDeregistration, error) {
	rows, err := q.db.Query(ctx, getValidatorMisbehaviorDeregistrationsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlValidatorMisbehaviorDeregistration
	for rows.Next() {
		var i EtlValidatorMisbehaviorDeregistration
		if err := rows.Scan(
			&i.ID,
			&i.CometAddress,
			&i.PubKey,
			&i.BlockHeight,
			&i.TxHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidatorRegistrations = `-- name: GetValidatorRegistrations :many
select vr.id, vr.address, vr.endpoint, vr.comet_address, vr.eth_block, vr.node_type, vr.spid, vr.comet_pubkey, vr.voting_power, vr.block_height, vr.tx_hash, v.endpoint, v.node_type, v.spid, v.voting_power, v.status
from etl_validator_registrations vr
left join etl_validators v on v.comet_address = vr.comet_address
order by vr.block_height desc
limit $1 offset $2
`

type GetValidatorRegistrationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetValidatorRegistrationsRow struct {
	ID            int32       `json:"id"`
	Address       string      `json:"address"`
	Endpoint      string      `json:"endpoint"`
	CometAddress  string      `json:"comet_address"`
	EthBlock      string      `json:"eth_block"`
	NodeType      string      `json:"node_type"`
	Spid          string      `json:"spid"`
	CometPubkey   []byte      `json:"comet_pubkey"`
	VotingPower   int64       `json:"voting_power"`
	BlockHeight   int64       `json:"block_height"`
	TxHash        string      `json:"tx_hash"`
	Endpoint_2    pgtype.Text `json:"endpoint_2"`
	NodeType_2    pgtype.Text `json:"node_type_2"`
	Spid_2        pgtype.Text `json:"spid_2"`
	VotingPower_2 pgtype.Int8 `json:"voting_power_2"`
	Status        pgtype.Text `json:"status"`
}

func (q *Queries) GetValidatorRegistrations(ctx context.Context, arg GetValidatorRegistrationsParams) ([]GetValidatorRegistrationsRow, error) {
	rows, err := q.db.Query(ctx, getValidatorRegistrations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetValidatorRegistrationsRow
	for rows.Next() {
		var i GetValidatorRegistrationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Endpoint,
			&i.CometAddress,
			&i.EthBlock,
			&i.NodeType,
			&i.Spid,
			&i.CometPubkey,
			&i.VotingPower,
			&i.BlockHeight,
			&i.TxHash,
			&i.Endpoint_2,
			&i.NodeType_2,
			&i.Spid_2,
			&i.VotingPower_2,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidatorRegistrationsByBlockHeightCursor = `-- name: GetValidatorRegistrationsByBlockHeightCursor :many
select id, address, endpoint, comet_address, eth_block, node_type, spid, comet_pubkey, voting_power, block_height, tx_hash from etl_validator_registrations
where block_height > $1 or (block_height = $1 and id > $2)
order by block_height, id
limit $3
`

type GetValidatorRegistrationsByBlockHeightCursorParams struct {
	BlockHeight int64 `json:"block_height"`
	ID          int32 `json:"id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) GetValidatorRegistrationsByBlockHeightCursor(ctx context.Context, arg GetValidatorRegistrationsByBlockHeightCursorParams) ([]EtlValidatorRegistration, error) {
	rows, err := q.db.Query(ctx, getValidatorRegistrationsByBlockHeightCursor, arg.BlockHeight, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EtlValidatorRegistration
	for rows.Next() {
		var i EtlValidatorRegistration
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Endpoint,
			&i.CometAddress,
			&i.EthBlock,
			&i.NodeType,
			&i.Spid,
			&i.CometPubkey,
			&i.VotingPower,
			&i.BlockHeight,
			&i.TxHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
