// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reads.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAvailableCities = `-- name: GetAvailableCities :many
select city, region, country, count(*) as play_count
from etl_plays
where city is not null
  and (nullif($1, '')::text is null or lower(country) = lower($1))
  and (nullif($2, '')::text is null or lower(region) = lower($2))
group by city, region, country
order by count(*) desc
limit $3
`

type GetAvailableCitiesParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
	Limit   int32       `json:"limit"`
}

type GetAvailableCitiesRow struct {
	City      string `json:"city"`
	Region    string `json:"region"`
	Country   string `json:"country"`
	PlayCount int64  `json:"play_count"`
}

func (q *Queries) GetAvailableCities(ctx context.Context, arg GetAvailableCitiesParams) ([]GetAvailableCitiesRow, error) {
	rows, err := q.db.Query(ctx, getAvailableCities, arg.Column1, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableCitiesRow
	for rows.Next() {
		var i GetAvailableCitiesRow
		if err := rows.Scan(
			&i.City,
			&i.Region,
			&i.Country,
			&i.PlayCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableCountries = `-- name: GetAvailableCountries :many
select country, count(*) as play_count
from etl_plays
where country is not null
group by country
order by count(*) desc
limit $1
`

type GetAvailableCountriesRow struct {
	Country   string `json:"country"`
	PlayCount int64  `json:"play_count"`
}

func (q *Queries) GetAvailableCountries(ctx context.Context, limit int32) ([]GetAvailableCountriesRow, error) {
	rows, err := q.db.Query(ctx, getAvailableCountries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableCountriesRow
	for rows.Next() {
		var i GetAvailableCountriesRow
		if err := rows.Scan(&i.Country, &i.PlayCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableRegions = `-- name: GetAvailableRegions :many
select region, country, count(*) as play_count
from etl_plays
where region is not null
  and (nullif($1, '')::text is null or lower(country) = lower($1))
group by region, country
order by count(*) desc
limit $2
`

type GetAvailableRegionsParams struct {
	Column1 interface{} `json:"column_1"`
	Limit   int32       `json:"limit"`
}

type GetAvailableRegionsRow struct {
	Region    string `json:"region"`
	Country   string `json:"country"`
	PlayCount int64  `json:"play_count"`
}

func (q *Queries) GetAvailableRegions(ctx context.Context, arg GetAvailableRegionsParams) ([]GetAvailableRegionsRow, error) {
	rows, err := q.db.Query(ctx, getAvailableRegions, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableRegionsRow
	for rows.Next() {
		var i GetAvailableRegionsRow
		if err := rows.Scan(&i.Region, &i.Country, &i.PlayCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockRangeByTime = `-- name: GetBlockRangeByTime :one
select
  min(block_height) as start_block,
  max(block_height) as end_block
from etl_blocks
where block_time between $1 and $2
`

type GetBlockRangeByTimeParams struct {
	BlockTime   pgtype.Timestamp `json:"block_time"`
	BlockTime_2 pgtype.Timestamp `json:"block_time_2"`
}

type GetBlockRangeByTimeRow struct {
	StartBlock interface{} `json:"start_block"`
	EndBlock   interface{} `json:"end_block"`
}

func (q *Queries) GetBlockRangeByTime(ctx context.Context, arg GetBlockRangeByTimeParams) (GetBlockRangeByTimeRow, error) {
	row := q.db.QueryRow(ctx, getBlockRangeByTime, arg.BlockTime, arg.BlockTime_2)
	var i GetBlockRangeByTimeRow
	err := row.Scan(&i.StartBlock, &i.EndBlock)
	return i, err
}

const getLatestIndexedBlock = `-- name: GetLatestIndexedBlock :one
select block_height 
from etl_blocks 
order by id desc 
limit 1
`

// get latest indexed block height
func (q *Queries) GetLatestIndexedBlock(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getLatestIndexedBlock)
	var block_height int64
	err := row.Scan(&block_height)
	return block_height, err
}

const getPlayCountByAddress = `-- name: GetPlayCountByAddress :one
select count(*) as play_count 
from etl_plays 
where address = $1
`

// get play count by address
func (q *Queries) GetPlayCountByAddress(ctx context.Context, address string) (int64, error) {
	row := q.db.QueryRow(ctx, getPlayCountByAddress, address)
	var play_count int64
	err := row.Scan(&play_count)
	return play_count, err
}

const getPlayCountByTrack = `-- name: GetPlayCountByTrack :one
select count(*) as play_count 
from etl_plays 
where track_id = $1
`

// get play count by track
func (q *Queries) GetPlayCountByTrack(ctx context.Context, trackID string) (int64, error) {
	row := q.db.QueryRow(ctx, getPlayCountByTrack, trackID)
	var play_count int64
	err := row.Scan(&play_count)
	return play_count, err
}

const getPlays = `-- name: GetPlays :many
select 
    address,
    track_id,
    extract(epoch from played_at)::bigint as timestamp,
    city,
    country,
    region,
    block_height,
    tx_hash
from etl_plays
where 
    block_height between $1 and $2
order by played_at desc
limit $3 offset $4
`

type GetPlaysParams struct {
	BlockHeight   int64 `json:"block_height"`
	BlockHeight_2 int64 `json:"block_height_2"`
	Limit         int32 `json:"limit"`
	Offset        int32 `json:"offset"`
}

type GetPlaysRow struct {
	Address     string `json:"address"`
	TrackID     string `json:"track_id"`
	Timestamp   int64  `json:"timestamp"`
	City        string `json:"city"`
	Country     string `json:"country"`
	Region      string `json:"region"`
	BlockHeight int64  `json:"block_height"`
	TxHash      string `json:"tx_hash"`
}

func (q *Queries) GetPlays(ctx context.Context, arg GetPlaysParams) ([]GetPlaysRow, error) {
	rows, err := q.db.Query(ctx, getPlays,
		arg.BlockHeight,
		arg.BlockHeight_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaysRow
	for rows.Next() {
		var i GetPlaysRow
		if err := rows.Scan(
			&i.Address,
			&i.TrackID,
			&i.Timestamp,
			&i.City,
			&i.Country,
			&i.Region,
			&i.BlockHeight,
			&i.TxHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaysByAddress = `-- name: GetPlaysByAddress :many
select 
    address,
    track_id,
    extract(epoch from played_at)::bigint as timestamp,
    city,
    country,
    region,
    block_height,
    tx_hash
from etl_plays
where 
    address = $1
    and block_height between $2 and $3
order by played_at desc
limit $4 offset $5
`

type GetPlaysByAddressParams struct {
	Address       string `json:"address"`
	BlockHeight   int64  `json:"block_height"`
	BlockHeight_2 int64  `json:"block_height_2"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

type GetPlaysByAddressRow struct {
	Address     string `json:"address"`
	TrackID     string `json:"track_id"`
	Timestamp   int64  `json:"timestamp"`
	City        string `json:"city"`
	Country     string `json:"country"`
	Region      string `json:"region"`
	BlockHeight int64  `json:"block_height"`
	TxHash      string `json:"tx_hash"`
}

func (q *Queries) GetPlaysByAddress(ctx context.Context, arg GetPlaysByAddressParams) ([]GetPlaysByAddressRow, error) {
	rows, err := q.db.Query(ctx, getPlaysByAddress,
		arg.Address,
		arg.BlockHeight,
		arg.BlockHeight_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaysByAddressRow
	for rows.Next() {
		var i GetPlaysByAddressRow
		if err := rows.Scan(
			&i.Address,
			&i.TrackID,
			&i.Timestamp,
			&i.City,
			&i.Country,
			&i.Region,
			&i.BlockHeight,
			&i.TxHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaysByLocation = `-- name: GetPlaysByLocation :many
select tx_hash, address, track_id, played_at, city, region, country, created_at
from etl_plays
where 
    (nullif($1, '')::text is null or lower(city) = lower($1)) and
    (nullif($2, '')::text is null or lower(region) = lower($2)) and
    (nullif($3, '')::text is null or lower(country) = lower($3))
order by played_at desc
limit $4
`

type GetPlaysByLocationParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
	Limit   int32       `json:"limit"`
}

type GetPlaysByLocationRow struct {
	TxHash    string           `json:"tx_hash"`
	Address   string           `json:"address"`
	TrackID   string           `json:"track_id"`
	PlayedAt  pgtype.Timestamp `json:"played_at"`
	City      string           `json:"city"`
	Region    string           `json:"region"`
	Country   string           `json:"country"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetPlaysByLocation(ctx context.Context, arg GetPlaysByLocationParams) ([]GetPlaysByLocationRow, error) {
	rows, err := q.db.Query(ctx, getPlaysByLocation,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaysByLocationRow
	for rows.Next() {
		var i GetPlaysByLocationRow
		if err := rows.Scan(
			&i.TxHash,
			&i.Address,
			&i.TrackID,
			&i.PlayedAt,
			&i.City,
			&i.Region,
			&i.Country,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaysByTrack = `-- name: GetPlaysByTrack :many
select 
    address,
    track_id,
    extract(epoch from played_at)::bigint as timestamp,
    city,
    country,
    region,
    block_height,
    tx_hash
from etl_plays
where 
    track_id = $1
    and block_height between $2 and $3
order by played_at desc
limit $4 offset $5
`

type GetPlaysByTrackParams struct {
	TrackID       string `json:"track_id"`
	BlockHeight   int64  `json:"block_height"`
	BlockHeight_2 int64  `json:"block_height_2"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

type GetPlaysByTrackRow struct {
	Address     string `json:"address"`
	TrackID     string `json:"track_id"`
	Timestamp   int64  `json:"timestamp"`
	City        string `json:"city"`
	Country     string `json:"country"`
	Region      string `json:"region"`
	BlockHeight int64  `json:"block_height"`
	TxHash      string `json:"tx_hash"`
}

func (q *Queries) GetPlaysByTrack(ctx context.Context, arg GetPlaysByTrackParams) ([]GetPlaysByTrackRow, error) {
	rows, err := q.db.Query(ctx, getPlaysByTrack,
		arg.TrackID,
		arg.BlockHeight,
		arg.BlockHeight_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaysByTrackRow
	for rows.Next() {
		var i GetPlaysByTrackRow
		if err := rows.Scan(
			&i.Address,
			&i.TrackID,
			&i.Timestamp,
			&i.City,
			&i.Country,
			&i.Region,
			&i.BlockHeight,
			&i.TxHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaysCount = `-- name: GetPlaysCount :one
select count(*) as total
from etl_plays
where 
    ($1::text is null or address = $1)
    and ($2::text is null or track_id = $2)
    and ($3::timestamp is null or $4::timestamp is null or played_at between $3 and $4)
`

type GetPlaysCountParams struct {
	Column1 string           `json:"column_1"`
	Column2 string           `json:"column_2"`
	Column3 pgtype.Timestamp `json:"column_3"`
	Column4 pgtype.Timestamp `json:"column_4"`
}

// get total count of plays with filtering
func (q *Queries) GetPlaysCount(ctx context.Context, arg GetPlaysCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getPlaysCount,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getValidatorDeregistrations = `-- name: GetValidatorDeregistrations :many
select 
    comet_address,
    comet_pubkey,
    block_height,
    tx_hash
from etl_validator_deregistrations
`

type GetValidatorDeregistrationsRow struct {
	CometAddress string `json:"comet_address"`
	CometPubkey  []byte `json:"comet_pubkey"`
	BlockHeight  int64  `json:"block_height"`
	TxHash       string `json:"tx_hash"`
}

// get validator deregistrations
func (q *Queries) GetValidatorDeregistrations(ctx context.Context) ([]GetValidatorDeregistrationsRow, error) {
	rows, err := q.db.Query(ctx, getValidatorDeregistrations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetValidatorDeregistrationsRow
	for rows.Next() {
		var i GetValidatorDeregistrationsRow
		if err := rows.Scan(
			&i.CometAddress,
			&i.CometPubkey,
			&i.BlockHeight,
			&i.TxHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidatorRegistrations = `-- name: GetValidatorRegistrations :many
select 
    address,
    comet_address,
    comet_pubkey,
    eth_block,
    node_type,
    spid,
    voting_power,
    block_height,
    tx_hash
from etl_validator_registrations
`

type GetValidatorRegistrationsRow struct {
	Address      string `json:"address"`
	CometAddress string `json:"comet_address"`
	CometPubkey  []byte `json:"comet_pubkey"`
	EthBlock     string `json:"eth_block"`
	NodeType     string `json:"node_type"`
	Spid         string `json:"spid"`
	VotingPower  int64  `json:"voting_power"`
	BlockHeight  int64  `json:"block_height"`
	TxHash       string `json:"tx_hash"`
}

// get validator registrations
func (q *Queries) GetValidatorRegistrations(ctx context.Context) ([]GetValidatorRegistrationsRow, error) {
	rows, err := q.db.Query(ctx, getValidatorRegistrations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetValidatorRegistrationsRow
	for rows.Next() {
		var i GetValidatorRegistrationsRow
		if err := rows.Scan(
			&i.Address,
			&i.CometAddress,
			&i.CometPubkey,
			&i.EthBlock,
			&i.NodeType,
			&i.Spid,
			&i.VotingPower,
			&i.BlockHeight,
			&i.TxHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
