// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reads.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getBlockRangeByTime = `-- name: GetBlockRangeByTime :one
select
  min(block_height) as start_block,
  max(block_height) as end_block
from etl_blocks
where block_time between $1 and $2
`

type GetBlockRangeByTimeParams struct {
	BlockTime   pgtype.Timestamp
	BlockTime_2 pgtype.Timestamp
}

type GetBlockRangeByTimeRow struct {
	StartBlock interface{}
	EndBlock   interface{}
}

func (q *Queries) GetBlockRangeByTime(ctx context.Context, arg GetBlockRangeByTimeParams) (GetBlockRangeByTimeRow, error) {
	row := q.db.QueryRow(ctx, getBlockRangeByTime, arg.BlockTime, arg.BlockTime_2)
	var i GetBlockRangeByTimeRow
	err := row.Scan(&i.StartBlock, &i.EndBlock)
	return i, err
}

const getLatestIndexedBlock = `-- name: GetLatestIndexedBlock :one
select block_height 
from etl_blocks 
order by id desc 
limit 1
`

// get latest indexed block height
func (q *Queries) GetLatestIndexedBlock(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getLatestIndexedBlock)
	var block_height int64
	err := row.Scan(&block_height)
	return block_height, err
}

const getPlayCountByAddress = `-- name: GetPlayCountByAddress :one
select count(*) as play_count 
from etl_plays 
where address = $1
`

// get play count by address
func (q *Queries) GetPlayCountByAddress(ctx context.Context, address string) (int64, error) {
	row := q.db.QueryRow(ctx, getPlayCountByAddress, address)
	var play_count int64
	err := row.Scan(&play_count)
	return play_count, err
}

const getPlayCountByTrack = `-- name: GetPlayCountByTrack :one
select count(*) as play_count 
from etl_plays 
where track_id = $1
`

// get play count by track
func (q *Queries) GetPlayCountByTrack(ctx context.Context, trackID string) (int64, error) {
	row := q.db.QueryRow(ctx, getPlayCountByTrack, trackID)
	var play_count int64
	err := row.Scan(&play_count)
	return play_count, err
}

const getPlays = `-- name: GetPlays :many
select 
    address,
    track_id,
    extract(epoch from played_at)::bigint as timestamp,
    city,
    country,
    region,
    block_height,
    tx_hash
from etl_plays
where 
    block_height between $1 and $2
order by played_at desc
limit $3 offset $4
`

type GetPlaysParams struct {
	BlockHeight   int64
	BlockHeight_2 int64
	Limit         int32
	Offset        int32
}

type GetPlaysRow struct {
	Address     string
	TrackID     string
	Timestamp   int64
	City        string
	Country     string
	Region      string
	BlockHeight int64
	TxHash      string
}

func (q *Queries) GetPlays(ctx context.Context, arg GetPlaysParams) ([]GetPlaysRow, error) {
	rows, err := q.db.Query(ctx, getPlays,
		arg.BlockHeight,
		arg.BlockHeight_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaysRow
	for rows.Next() {
		var i GetPlaysRow
		if err := rows.Scan(
			&i.Address,
			&i.TrackID,
			&i.Timestamp,
			&i.City,
			&i.Country,
			&i.Region,
			&i.BlockHeight,
			&i.TxHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaysByAddress = `-- name: GetPlaysByAddress :many
select 
    address,
    track_id,
    extract(epoch from played_at)::bigint as timestamp,
    city,
    country,
    region,
    block_height,
    tx_hash
from etl_plays
where 
    address = $1
    and block_height between $2 and $3
order by played_at desc
limit $4 offset $5
`

type GetPlaysByAddressParams struct {
	Address       string
	BlockHeight   int64
	BlockHeight_2 int64
	Limit         int32
	Offset        int32
}

type GetPlaysByAddressRow struct {
	Address     string
	TrackID     string
	Timestamp   int64
	City        string
	Country     string
	Region      string
	BlockHeight int64
	TxHash      string
}

func (q *Queries) GetPlaysByAddress(ctx context.Context, arg GetPlaysByAddressParams) ([]GetPlaysByAddressRow, error) {
	rows, err := q.db.Query(ctx, getPlaysByAddress,
		arg.Address,
		arg.BlockHeight,
		arg.BlockHeight_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaysByAddressRow
	for rows.Next() {
		var i GetPlaysByAddressRow
		if err := rows.Scan(
			&i.Address,
			&i.TrackID,
			&i.Timestamp,
			&i.City,
			&i.Country,
			&i.Region,
			&i.BlockHeight,
			&i.TxHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaysByTrack = `-- name: GetPlaysByTrack :many
select 
    address,
    track_id,
    extract(epoch from played_at)::bigint as timestamp,
    city,
    country,
    region,
    block_height,
    tx_hash
from etl_plays
where 
    track_id = $1
    and block_height between $2 and $3
order by played_at desc
limit $4 offset $5
`

type GetPlaysByTrackParams struct {
	TrackID       string
	BlockHeight   int64
	BlockHeight_2 int64
	Limit         int32
	Offset        int32
}

type GetPlaysByTrackRow struct {
	Address     string
	TrackID     string
	Timestamp   int64
	City        string
	Country     string
	Region      string
	BlockHeight int64
	TxHash      string
}

func (q *Queries) GetPlaysByTrack(ctx context.Context, arg GetPlaysByTrackParams) ([]GetPlaysByTrackRow, error) {
	rows, err := q.db.Query(ctx, getPlaysByTrack,
		arg.TrackID,
		arg.BlockHeight,
		arg.BlockHeight_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaysByTrackRow
	for rows.Next() {
		var i GetPlaysByTrackRow
		if err := rows.Scan(
			&i.Address,
			&i.TrackID,
			&i.Timestamp,
			&i.City,
			&i.Country,
			&i.Region,
			&i.BlockHeight,
			&i.TxHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaysCount = `-- name: GetPlaysCount :one
select count(*) as total
from etl_plays
where 
    ($1::text is null or address = $1)
    and ($2::text is null or track_id = $2)
    and ($3::timestamp is null or $4::timestamp is null or played_at between $3 and $4)
`

type GetPlaysCountParams struct {
	Column1 string
	Column2 string
	Column3 pgtype.Timestamp
	Column4 pgtype.Timestamp
}

// get total count of plays with filtering
func (q *Queries) GetPlaysCount(ctx context.Context, arg GetPlaysCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getPlaysCount,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}
