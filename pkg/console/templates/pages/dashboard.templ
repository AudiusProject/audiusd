package pages

import (
	"fmt"
	"github.com/AudiusProject/audiusd/pkg/console/templates"
	"github.com/AudiusProject/audiusd/pkg/console/templates/layouts"
	"github.com/AudiusProject/audiusd/pkg/etl/db"
	"strconv"
	"strings"
)

type DashboardStats struct {
	CurrentBlockHeight           int64
	ChainID                      string
	BPS                          float64
	TPS                          float64
	TotalTransactions            int64
	ValidatorCount               int64
	LatestBlock                  *db.EtlBlock
	RecentProposers              []string
	IsSyncing                    bool
	LatestIndexedHeight          int64
	LatestChainHeight            int64
	BlockDelta                   int64
	TotalTransactions24h         int64
	TotalTransactionsPrevious24h int64
	TotalTransactions7d          int64
	TotalTransactions30d         int64
	AvgBlockTime                 float32 // Average block time from latest SLA rollup in seconds
}

type TransactionTypeBreakdown struct {
	Type  string
	Count int64
	Color string
}

type PlayEvent struct {
	Timestamp string  `json:"timestamp"`
	Lat       float64 `json:"lat"`
	Lng       float64 `json:"lng"`
	Duration  int     `json:"duration"`
}

type DashboardProps struct {
	Stats                  *DashboardStats
	TransactionBreakdown   []*TransactionTypeBreakdown
	RecentBlocks           []*db.EtlBlock
	RecentTransactions     []*db.EtlTransaction
	BlockHeights           map[string]int64
	SyncProgressPercentage float64
}

func formatNumber(n int64) string {
	str := strconv.FormatInt(n, 10)
	if len(str) <= 3 {
		return str
	}

	var result strings.Builder
	for i, char := range str {
		if i > 0 && (len(str)-i)%3 == 0 {
			result.WriteString(",")
		}
		result.WriteRune(char)
	}
	return result.String()
}

func getTotalTransactionCount(breakdown []*TransactionTypeBreakdown) int64 {
	var total int64
	for _, b := range breakdown {
		total += b.Count
	}
	return total
}

func getProgressBarClass(percentage float64) string {
	switch {
	case percentage >= 99:
		return "w-full"
	case percentage >= 95:
		return "w-11/12"
	case percentage >= 90:
		return "w-5/6"
	case percentage >= 80:
		return "w-4/5"
	case percentage >= 75:
		return "w-3/4"
	case percentage >= 60:
		return "w-3/5"
	case percentage >= 50:
		return "w-1/2"
	case percentage >= 40:
		return "w-2/5"
	case percentage >= 25:
		return "w-1/4"
	case percentage >= 20:
		return "w-1/5"
	case percentage >= 10:
		return "w-1/12"
	case percentage >= 5:
		return "w-1/24"
	default:
		return "w-px"
	}
}

func getPercentageChangeText(current, previous int64) string {
	if previous == 0 {
		return "No previous data"
	}

	change := float64(current-previous) / float64(previous) * 100
	if change >= 0 {
		return fmt.Sprintf("+%.1f%% from yesterday", change)
	} else {
		return fmt.Sprintf("%.1f%% from yesterday", change)
	}
}

func getPercentageChangeColorClass(current, previous int64) string {
	if previous == 0 {
		return "text-gray-500 dark:text-gray-400"
	}

	change := float64(current-previous) / float64(previous) * 100
	if change >= 0 {
		return "text-green-600 dark:text-green-400"
	} else {
		return "text-red-600 dark:text-red-400"
	}
}

templ Dashboard(props DashboardProps) {
	@layouts.Base("Dashboard") {
		<div class="space-y-6" x-data="blockEvents()" x-init="init()">
			<!-- Section 1: Current Stats -->
			<div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6">
				<div id="stats-header" x-data="blockEvents()" x-init="init()">
					<div class="flex items-center justify-between">
						<div class="flex-1">
							<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Block Height</h4>
							<div class="flex items-center h-12" x-data="animatedNumber()" x-init="init(latestBlock.height)">
								<template x-for="(digit, index) in digits" :key="index">
									<div class="relative h-10 w-6 overflow-hidden flex items-center justify-center">
										<!-- Current digit (slides down when animating) -->
										<div class="absolute inset-0 flex items-center justify-center">
											<span
												class="text-3xl font-bold text-gray-900 dark:text-gray-100 tabular-nums"
												:class="getCurrentDigitClass(digit)"
												x-text="digit.current"
											></span>
										</div>
										<!-- Next digit (slides in from above when animating) -->
										<div class="absolute inset-0 flex items-center justify-center">
											<span
												class="text-3xl font-bold text-gray-900 dark:text-gray-100 tabular-nums"
												:class="getNextDigitClass(digit)"
												x-text="digit.next"
											></span>
										</div>
									</div>
								</template>
							</div>
						</div>
						<div class="flex-1 border-l border-gray-200 dark:border-gray-700 pl-6">
							<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Chain ID</h4>
							<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">{ props.Stats.ChainID }</p>
						</div>
						<div class="flex-none w-32 border-l border-gray-200 dark:border-gray-700 pl-6">
							<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Block Time</h4>
							if props.Stats.AvgBlockTime > 0 {
								<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">{ fmt.Sprintf("%.2fs", props.Stats.AvgBlockTime) }</p>
							} else if props.Stats.BPS > 0 {
								<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">{ fmt.Sprintf("%.2fs", 1.0/props.Stats.BPS) }</p>
								<p class="text-xs text-gray-500 dark:text-gray-400">{ fmt.Sprintf("%.2f BPS", props.Stats.BPS) }</p>
							} else {
								<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">-</p>
								<p class="text-xs text-gray-500 dark:text-gray-400">No data</p>
							}
						</div>
						<div class="flex-none w-40 border-l border-gray-200 dark:border-gray-700 pl-6">
							<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Sync Status</h4>
							if props.Stats.IsSyncing {
								<div class="flex items-center">
									<div class="w-2 h-2 bg-yellow-500 rounded-full mr-2 animate-pulse"></div>
									<p class="text-xl font-bold text-yellow-600 dark:text-yellow-400">Syncing</p>
								</div>
							} else {
								<div class="flex items-center">
									<div class="w-2 h-2 bg-green-500 rounded-full mr-2"></div>
									<p class="text-xl font-bold text-green-600 dark:text-green-400">Synced</p>
								</div>
								<p class="text-xs text-gray-500 dark:text-gray-400">Up to date</p>
							}
						</div>
					</div>
					<!-- Sync Progress Bar -->
					if props.Stats.IsSyncing && props.Stats.LatestChainHeight > 0 {
						<div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
							<div class="flex items-center justify-between mb-2">
								<span class="text-xs font-medium text-gray-600 dark:text-gray-400">
									Sync Progress
									if props.Stats.BlockDelta > 0 {
										| { fmt.Sprintf("%d blocks to go", props.Stats.BlockDelta) }
									}
								</span>
								<span class="text-xs text-gray-500 dark:text-gray-500">
									{ fmt.Sprintf("%d / %d", props.Stats.LatestIndexedHeight, props.Stats.LatestChainHeight) }
									({ fmt.Sprintf("%.1f%%", props.SyncProgressPercentage) })
								</span>
							</div>
							<div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2 relative overflow-hidden">
								<!-- Exact progress representation using calculated percentage -->
								<div
									class={ fmt.Sprintf("bg-purple-600 h-2 rounded-full transition-all duration-300 ease-in-out %s", getProgressBarClass(props.SyncProgressPercentage)) }
								></div>
							</div>
						</div>
					}
				</div>
			</div>
			<!-- Section 2: Live Map & Validator Info -->
			<div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl overflow-hidden">
				<div class="relative">
					<!-- Map - Full Background -->
					<div
						class="relative bg-gray-100 dark:bg-gray-700 h-96 z-10"
						x-data="livePlayMap()"
						x-init="initSSEEventSource(); initMap()"
					>
						<!-- Map container -->
						<div id="playMap" class="w-full h-full"></div>
						<!-- Connection status -->
						<div class="absolute top-4 left-4 bg-black/20 backdrop-blur-sm rounded px-2 py-1" x-show="!connected">
							<span class="text-white/90 text-xs">Connecting...</span>
						</div>
					</div>
					<!-- Network Info Overlay - Left Side (aligned with zoom buttons) -->
					<div class="absolute top-14 left-16 w-56 z-20">
						<div id="network-sidebar" class="space-y-2" x-data="blockEvents()" x-init={ fmt.Sprintf("init({ validatorCount: %d })", props.Stats.ValidatorCount) }>
							@NetworkSidebarFragment(props.Stats)
						</div>
					</div>
				</div>
			</div>
			<!-- Section 3: Transaction Analytics -->
			<div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6">
				<div class="flex items-center justify-between mb-6">
					<h3 class="text-xl font-bold text-gray-900 dark:text-gray-100">Network Performance</h3>
				</div>
				<div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
					<!-- Primary Metrics -->
					<div class="lg:col-span-2 space-y-6">
						<!-- Top row: TPS and Total Transactions -->
						<div class="grid grid-cols-2 gap-6">
							<div id="tps-fragment" hx-get="/fragments/tps" hx-trigger="every 5s" hx-swap="outerHTML">
								@TPSFragment(props.Stats)
							</div>
							<div id="total-transactions-fragment" hx-get="/fragments/total-transactions" hx-trigger="every 10s" hx-swap="outerHTML">
								@TotalTransactionsFragment(props.Stats)
							</div>
						</div>
						<!-- Bottom row: Volume metrics -->
						<div class="grid grid-cols-3 border-t border-gray-200 dark:border-gray-700 pt-6">
							<div class="border-r border-gray-200 dark:border-gray-700 pr-6">
								<div class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-1">24h Volume</div>
								<div class="text-2xl font-light text-gray-900 dark:text-gray-100 mb-1">{ formatNumber(props.Stats.TotalTransactions24h) }</div>
								<div class="text-xs text-gray-500 dark:text-gray-400">Daily rate</div>
							</div>
							<div class="border-r border-gray-200 dark:border-gray-700 pr-6 pl-6">
								<div class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-1">7d Volume</div>
								<div class="text-2xl font-light text-gray-900 dark:text-gray-100 mb-1">{ formatNumber(props.Stats.TotalTransactions7d) }</div>
								<div class="text-xs text-gray-500 dark:text-gray-400">Avg: { formatNumber(props.Stats.TotalTransactions7d / 7) }/day</div>
							</div>
							<div class="pl-6">
								<div class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-1">30d Volume</div>
								<div class="text-2xl font-light text-gray-900 dark:text-gray-100 mb-1">{ formatNumber(props.Stats.TotalTransactions30d) }</div>
								<div class="text-xs text-gray-500 dark:text-gray-400">Avg: { formatNumber(props.Stats.TotalTransactions30d / 30) }/day</div>
							</div>
						</div>
					</div>
					<!-- Transaction Types -->
					<div class="border-l border-gray-200 dark:border-gray-700 pl-6">
						<div class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-4">Transaction Types</div>
						<div class="space-y-3">
							if len(props.TransactionBreakdown) > 0 {
								for _, breakdown := range props.TransactionBreakdown {
									<div class="flex items-center justify-between">
										<span class="text-xs px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-gray-600 dark:text-gray-400">{ breakdown.Type }</span>
										<span class="text-sm font-medium text-gray-900 dark:text-gray-100 tabular-nums">{ formatNumber(breakdown.Count) }</span>
									</div>
								}
							} else {
								<div class="text-sm text-gray-500 dark:text-gray-400">No transaction data available</div>
							}
						</div>
					</div>
				</div>
			</div>
			<!-- Section 4: Recent Blocks & Transactions -->
			<div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
				<!-- Latest Blocks -->
				<div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6">
					<div class="flex justify-between items-center mb-4">
						<h3 class="text-xl font-bold text-gray-900 dark:text-gray-100">Latest Blocks</h3>
						<a href="/blocks" class="text-purple-600 dark:text-purple-400 hover:text-purple-800 dark:hover:text-purple-300 hover:underline text-sm">View all →</a>
					</div>
					if len(props.RecentBlocks) > 0 {
						<div class="space-y-2">
							for _, block := range props.RecentBlocks {
								<div class="flex items-center justify-between py-3 px-4 border border-gray-200 dark:border-gray-700 rounded hover:bg-purple-50 hover:border-purple-200 dark:hover:bg-gray-700 transition-colors">
									<div class="flex items-center gap-4">
										<a href={ templ.SafeURL(fmt.Sprintf("/block/%d", block.BlockHeight)) } class="font-semibold text-purple-600 dark:text-purple-400 hover:underline">
											{ fmt.Sprintf("#%d", block.BlockHeight) }
										</a>
										<a href={ templ.SafeURL(fmt.Sprintf("/validator/%s", block.ProposerAddress)) } class="font-mono text-xs text-purple-600 dark:text-purple-400 hover:underline">
											if len(block.ProposerAddress) > 8 {
												{ block.ProposerAddress[:4] }...{ block.ProposerAddress[len(block.ProposerAddress)-4:] }
											} else {
												{ block.ProposerAddress }
											}
										</a>
									</div>
									<div class="text-xs text-gray-500 dark:text-gray-400">
										if block.BlockTime.Valid {
											@templates.TimeWithTooltip(block.BlockTime.Time)
										} else {
											<span>—</span>
										}
									</div>
								</div>
							}
						</div>
					} else {
						<p class="text-gray-500 dark:text-gray-400">No blocks found</p>
					}
				</div>
				<!-- Latest Transactions -->
				<div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6">
					<div class="flex justify-between items-center mb-4">
						<h3 class="text-xl font-bold text-gray-900 dark:text-gray-100">Latest Transactions</h3>
						<a href="/transactions" class="text-purple-600 dark:text-purple-400 hover:text-purple-800 dark:hover:text-purple-300 hover:underline text-sm">View all →</a>
					</div>
					if len(props.RecentTransactions) > 0 {
						<div class="space-y-2">
							for _, tx := range props.RecentTransactions {
								<div class="flex items-center justify-between py-3 px-4 border border-gray-200 dark:border-gray-700 rounded hover:bg-purple-50 hover:border-purple-200 dark:hover:bg-gray-700 transition-colors">
									<div class="flex items-center gap-4">
										<a href={ templ.SafeURL(fmt.Sprintf("/transaction/%s", tx.TxHash)) } class="font-mono text-sm text-purple-600 dark:text-purple-400 hover:underline">
											if len(tx.TxHash) > 8 {
												{ tx.TxHash[:4] }...{ tx.TxHash[len(tx.TxHash)-4:] }
											} else {
												{ tx.TxHash }
											}
										</a>
										<span class="text-xs px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-gray-600 dark:text-gray-400">
											{ tx.TxType }
										</span>
										if blockHeight, exists := props.BlockHeights[tx.TxHash]; exists {
											<a href={ templ.SafeURL(fmt.Sprintf("/block/%d", blockHeight)) } class="text-xs text-purple-600 dark:text-purple-400 hover:underline">
												{ fmt.Sprintf("#%d", blockHeight) }
											</a>
										}
									</div>
									<div class="text-xs text-gray-500 dark:text-gray-400">
										if tx.CreatedAt.Valid {
											@templates.TimeWithTooltip(tx.CreatedAt.Time)
										} else {
											<span>—</span>
										}
									</div>
								</div>
							}
						</div>
					} else {
						<p class="text-gray-500 dark:text-gray-400">No transactions found</p>
					}
				</div>
			</div>
		</div>
		@SSEEventScript()
		@LivePlayMapScript()
		@BlockEventsScript()
	}
}

// HTMX Fragment Templates
templ StatsHeaderFragment(stats *DashboardStats, syncProgressPercentage float64) {
	<div id="stats-header">
		<div class="flex items-center justify-between">
			<div class="flex-1">
				<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Block Height</h4>
				<div class="flex items-center h-12" x-data="animatedNumber()" x-init="init(latestBlock.height)">
					<template x-for="(digit, index) in digits" :key="index">
						<div class="relative h-10 w-6 overflow-hidden flex items-center justify-center">
							<!-- Current digit (slides down when animating) -->
							<div class="absolute inset-0 flex items-center justify-center">
								<span
									class="text-3xl font-bold text-gray-900 dark:text-gray-100 tabular-nums"
									:class="getCurrentDigitClass(digit)"
									x-text="digit.current"
								></span>
							</div>
							<!-- Next digit (slides in from above when animating) -->
							<div class="absolute inset-0 flex items-center justify-center">
								<span
									class="text-3xl font-bold text-gray-900 dark:text-gray-100 tabular-nums"
									:class="getNextDigitClass(digit)"
									x-text="digit.next"
								></span>
							</div>
						</div>
					</template>
				</div>
			</div>
			<div class="flex-1 border-l border-gray-200 dark:border-gray-700 pl-6">
				<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Chain ID</h4>
				<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">{ stats.ChainID }</p>
			</div>
			<div class="flex-none w-32 border-l border-gray-200 dark:border-gray-700 pl-6">
				<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Block Time</h4>
				if stats.AvgBlockTime > 0 {
					<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">{ fmt.Sprintf("%.2fs", stats.AvgBlockTime) }</p>
				} else if stats.BPS > 0 {
					<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">{ fmt.Sprintf("%.2fs", 1.0/stats.BPS) }</p>
					<p class="text-xs text-gray-500 dark:text-gray-400">{ fmt.Sprintf("%.2f BPS", stats.BPS) }</p>
				} else {
					<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">-</p>
					<p class="text-xs text-gray-500 dark:text-gray-400">No data</p>
				}
			</div>
			<div class="flex-none w-40 border-l border-gray-200 dark:border-gray-700 pl-6">
				<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Sync Status</h4>
				if stats.IsSyncing {
					<div class="flex items-center">
						<div class="w-2 h-2 bg-yellow-500 rounded-full mr-2 animate-pulse"></div>
						<p class="text-xl font-bold text-yellow-600 dark:text-yellow-400">Syncing</p>
					</div>
				} else {
					<div class="flex items-center">
						<div class="w-2 h-2 bg-green-500 rounded-full mr-2"></div>
						<p class="text-xl font-bold text-green-600 dark:text-green-400">Synced</p>
					</div>
					<p class="text-xs text-gray-500 dark:text-gray-400">Up to date</p>
				}
			</div>
		</div>
		<!-- Sync Progress Bar -->
		if stats.IsSyncing && stats.LatestChainHeight > 0 {
			<div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
				<div class="flex items-center justify-between mb-2">
					<span class="text-xs font-medium text-gray-600 dark:text-gray-400">
						Sync Progress
						if stats.BlockDelta > 0 {
							| { fmt.Sprintf("%d blocks to go", stats.BlockDelta) }
						}
					</span>
					<span class="text-xs text-gray-500 dark:text-gray-500">
						{ fmt.Sprintf("%d / %d", stats.LatestIndexedHeight, stats.LatestChainHeight) }
						({ fmt.Sprintf("%.1f%%", syncProgressPercentage) })
					</span>
				</div>
				<div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2 relative overflow-hidden">
					<!-- Exact progress representation using calculated percentage -->
					<div
						class={ fmt.Sprintf("bg-purple-600 h-2 rounded-full transition-all duration-300 ease-in-out %s", getProgressBarClass(syncProgressPercentage)) }
					></div>
				</div>
			</div>
		}
	</div>
}

templ TPSFragment(stats *DashboardStats) {
	<div id="tps-fragment" hx-get="/fragments/tps" hx-trigger="every 5s" hx-swap="outerHTML" class="border-r border-gray-200 dark:border-gray-700 pr-6">
		<div class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-1">Transactions/sec</div>
		<div class="text-4xl font-light text-gray-900 dark:text-gray-100 mb-1">{ fmt.Sprintf("%.1f", stats.TPS) }</div>
		<div class="text-xs text-gray-500 dark:text-gray-400">30d Avg: { fmt.Sprintf("%.1f", float64(stats.TotalTransactions30d)/(30*24*60*60)) } TPS</div>
	</div>
}

templ TotalTransactionsFragment(stats *DashboardStats) {
	<div id="total-transactions-fragment" hx-get="/fragments/total-transactions" hx-trigger="every 10s" hx-swap="outerHTML" class="pr-6">
		<div class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-1">Total Transactions</div>
		<div class="text-4xl font-light text-gray-900 dark:text-gray-100 mb-1">{ formatNumber(stats.TotalTransactions) }</div>
		<div class={ fmt.Sprintf("text-xs %s", getPercentageChangeColorClass(stats.TotalTransactions24h, stats.TotalTransactionsPrevious24h)) }>{ getPercentageChangeText(stats.TotalTransactions24h, stats.TotalTransactionsPrevious24h) }</div>
	</div>
}

templ SSEEventScript() {
	<script>
		let globalEventSource = null;

		function initSSEEventSource() {
			// Close existing connection if any
			if (globalEventSource) {
				globalEventSource.close();
			}

			globalEventSource = new EventSource('/sse/events');

			// Dispatch custom events for each SSE event
			globalEventSource.onmessage = (event) => {
				try {
					const data = JSON.parse(event.data);
					document.dispatchEvent(new CustomEvent(data.event, { detail: data.data }));
				} catch (e) {
					console.error('Error parsing SSE event data:', e, event.data);
				}
			};

			globalEventSource.onerror = (error) => {
				console.error('SSE connection error:', error);
			};

			globalEventSource.onopen = () => {
				console.log('SSE connection opened');
			};

			// Cleanup on page unload
			window.addEventListener('beforeunload', () => {
				if (globalEventSource) {
					globalEventSource.close();
					globalEventSource = null;
				}
			});

			// Cleanup on page visibility change (mobile browsers)
			document.addEventListener('visibilitychange', () => {
				if (document.hidden && globalEventSource) {
					globalEventSource.close();
					globalEventSource = null;
				} else if (!document.hidden && !globalEventSource) {
					// Reconnect when page becomes visible again
					setTimeout(() => {
						initSSEEventSource();
					}, 1000);
				}
			});

			return globalEventSource;
		}

		// Cleanup when Alpine.js is destroyed
		document.addEventListener('alpine:init', () => {
			Alpine.store('cleanup', {
				eventSource: null,
				init() {
					this.eventSource = initSSEEventSource();
				},
				destroy() {
					if (this.eventSource) {
						this.eventSource.close();
						this.eventSource = null;
					}
				}
			});
		});
	</script>
}

// Live Play Map Alpine.js Component
templ LivePlayMapScript() {
	<script>
		function livePlayMap() {
			return {
				map: null,
				eventSource: null,
				connected: false,
				playMarkers: [],
				playEventListener: null,
				animationFrames: new Set(),
				timeouts: new Set(),
				
				initMap() {
					// Create bound event listener for proper cleanup
					this.playEventListener = (event) => {
						this.addPlayToMap(event.detail);
					};
					document.addEventListener('play', this.playEventListener);

					// Initialize Leaflet map focused on US
					this.map = L.map('playMap').setView([39.0, -110.0], 5);
					
					// Detect dark mode and use appropriate tiles
					const isDarkMode = document.documentElement.classList.contains('dark') || 
					                  window.matchMedia('(prefers-color-scheme: dark)').matches;
					
					if (isDarkMode) {
						// Dark mode tiles
						L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
							attribution: '© OpenStreetMap, © CartoDB',
							subdomains: 'abcd'
						}).addTo(this.map);
					} else {
						// Light mode tiles
						L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
							attribution: '© OpenStreetMap contributors'
						}).addTo(this.map);
					}

					// Setup cleanup on page unload
					window.addEventListener('beforeunload', () => {
						this.cleanup();
					});

					// Setup cleanup on Alpine destroy
					this.$watch('$store.cleanup', () => {
						// This will be called when Alpine is destroyed
					});
				},
				
				addPlayToMap(play) {
					if (!this.map) return;
					
					// Set default duration if not provided
					if (!play.duration) {
						play.duration = 5; // Default 5 seconds
					}
					
					const color = this.getRandomColor();
					
					// Create radar-style animation with expanding circles
					const radarGroup = L.layerGroup().addTo(this.map);
					
					// Create multiple expanding circles for radar effect
					for (let i = 0; i < 3; i++) {
						const timeout = setTimeout(() => {
							const circle = L.circle([play.lat, play.lng], {
								radius: 0,
								fillColor: color,
								color: color,
								weight: 2,
								opacity: 0.8,
								fillOpacity: 0.3
							}).addTo(radarGroup);
							
							// Animate the circle expansion
							let radius = 0;
							let opacity = 0.8;
							const maxRadius = 100000; // 100km in meters
							const animationDuration = 1000; // Fixed 1 second animation duration
							const startTime = Date.now();
							
							const animate = () => {
								const elapsed = Date.now() - startTime;
								const progress = Math.min(elapsed / animationDuration, 1);
								
								radius = maxRadius * progress;
								opacity = 0.8 * (1 - progress);
								
								circle.setRadius(radius);
								circle.setStyle({ 
									opacity: opacity,
									fillOpacity: opacity * 0.3
								});
								
								if (progress < 1) {
									const frameId = requestAnimationFrame(animate);
									this.animationFrames.add(frameId);
								} else {
									radarGroup.removeLayer(circle);
								}
							};
							
							animate();
						}, i * 200); // Stagger each circle by 200ms
						
						this.timeouts.add(timeout);
					}
					
					// Add center dot
					const centerDot = L.circleMarker([play.lat, play.lng], {
						radius: 4,
						fillColor: color,
						color: '#ffffff',
						weight: 2,
						opacity: 1,
						fillOpacity: 1
					}).addTo(radarGroup);
					
					// Add popup with play info
					const timestamp = play.timestamp ? new Date(play.timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
					centerDot.bindPopup(`Play at ${timestamp}`);
					
					// Store group for cleanup
					this.playMarkers.push(radarGroup);
					
					// Remove entire radar group after duration
					const cleanupTimeout = setTimeout(() => {
						if (this.map && this.map.hasLayer(radarGroup)) {
							this.map.removeLayer(radarGroup);
						}
						this.playMarkers = this.playMarkers.filter(m => m !== radarGroup);
					}, play.duration * 1000);
					
					this.timeouts.add(cleanupTimeout);
				},
				
				getRandomColor() {
					const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7'];
					return colors[Math.floor(Math.random() * colors.length)];
				},
				
				cleanup() {
					// Clear all timeouts
					this.timeouts.forEach(timeout => clearTimeout(timeout));
					this.timeouts.clear();
					
					// Cancel all animation frames
					this.animationFrames.forEach(frameId => cancelAnimationFrame(frameId));
					this.animationFrames.clear();
					
					// Remove event listener
					if (this.playEventListener) {
						document.removeEventListener('play', this.playEventListener);
						this.playEventListener = null;
					}
					
					// Clean up map markers
					this.playMarkers.forEach(marker => {
						if (this.map && this.map.hasLayer(marker)) {
							this.map.removeLayer(marker);
						}
					});
					this.playMarkers = [];
					
					// Remove map
					if (this.map) {
						this.map.remove();
						this.map = null;
					}
				},

				// Alpine.js lifecycle hook
				destroy() {
					this.cleanup();
				}
			}
		}
	</script>
}

// Block Events Alpine.js Component
templ BlockEventsScript() {
	<script>
		function animatedNumber() {
			return {
				displayValue: 0,
				digits: [],
				blockEventListener: null,
				animationTimeouts: new Set(),
				
				init(initialValue) {
					this.displayValue = initialValue || 0;
					this.updateDigits(this.displayValue);
					
					// Create bound event listener for proper cleanup
					this.blockEventListener = (event) => {
						if (event.detail && event.detail.height && event.detail.height !== this.displayValue) {
							this.animateToNewValue(event.detail.height);
						}
					};
					
					// Listen directly to block events instead of watching parent data
					document.addEventListener('block', this.blockEventListener);
				},
				
				updateDigits(value) {
					const str = value.toString();
					const newDigits = [];
					
					// Pad with leading zeros if necessary to maintain consistent width
					const maxLength = Math.max(str.length, this.digits.length);
					const paddedStr = str.padStart(maxLength, '0');
					
					for (let i = 0; i < paddedStr.length; i++) {
						const digit = parseInt(paddedStr[i]);
						const existingDigit = this.digits[i];
						
						if (existingDigit) {
							// Keep existing digit state but update target
							newDigits.push({
								...existingDigit,
								next: digit,
								isAnimating: existingDigit.current !== digit
							});
						} else {
							// New digit
							newDigits.push({
								current: digit,
								next: digit,
								isAnimating: false
							});
						}
					}
					
					this.digits = newDigits;
				},
				
				animateToNewValue(newValue) {
					if (newValue === this.displayValue) return;
					
					this.updateDigits(newValue);
					
					// Start animations for changed digits
					this.digits.forEach((digit, index) => {
						if (digit.isAnimating) {
							this.animateDigit(index);
						}
					});
					
					this.displayValue = newValue;
				},
				
				animateDigit(index) {
					const digit = this.digits[index];
					
					// Mark as animating
					digit.isAnimating = true;
					
					// After animation duration, update the current digit and stop animating
					const timeout = setTimeout(() => {
						digit.current = digit.next;
						digit.isAnimating = false;
						this.animationTimeouts.delete(timeout);
					}, 300); // Animation duration
					
					this.animationTimeouts.add(timeout);
				},
				
				getCurrentDigitClass(digit) {
					if (digit.isAnimating) {
						return 'transform translate-y-full opacity-0 transition-all duration-300 ease-in-out';
					}
					return 'transform translate-y-0 opacity-100';
				},
				
				getNextDigitClass(digit) {
					if (digit.isAnimating) {
						return 'transform translate-y-0 opacity-100 transition-all duration-300 ease-in-out';
					}
					return 'transform -translate-y-full opacity-0';
				},

				// Alpine.js lifecycle hook
				destroy() {
					// Clear all animation timeouts
					this.animationTimeouts.forEach(timeout => clearTimeout(timeout));
					this.animationTimeouts.clear();
					
					// Remove event listener
					if (this.blockEventListener) {
						document.removeEventListener('block', this.blockEventListener);
						this.blockEventListener = null;
					}
				}
			}
		}

		function blockEvents() {
			return {
				recentBlocks: [],
				latestBlock: { height: 0, proposer: '' },
				validatorCount: 0,
				blockEventListener: null,
				
				init(initialState = {}) {
					// Set initial state from server-rendered values
					const networkSidebar = document.querySelector('#network-sidebar');
					const statsHeader = document.querySelector('#stats-header');
					
					// Set initial validator count from server
					if (initialState.validatorCount) {
						this.validatorCount = parseInt(initialState.validatorCount);
					}

					if (networkSidebar) {
						const blockHeightEl = networkSidebar.querySelector('a[href^="/block/"]');
						const proposerEl = networkSidebar.querySelector('a[href^="/validator/"]');

						if (blockHeightEl && proposerEl) {
							this.latestBlock = {
								height: parseInt(blockHeightEl.textContent.replace('#', '')),
								proposer: proposerEl.href.split('/').pop()
							};
						}
					}

					// Also get initial block height from stats header
					if (statsHeader) {
						const blockHeightEl = statsHeader.querySelector('.text-3xl');
						if (blockHeightEl) {
							this.latestBlock.height = parseInt(blockHeightEl.textContent);
						}
					}

					// Create bound event listener for proper cleanup
					this.blockEventListener = (event) => {
						this.handleBlockEvent(event.detail);
					};
					
					document.addEventListener('block', this.blockEventListener);
				},

				formatProposer(proposer) {
					return proposer.length > 12 
						? `${proposer.slice(0, 6)}...${proposer.slice(-4)}`
						: proposer;
				},

				handleBlockEvent(blockData) {
					// Check if we already have this block
					const existingBlockIndex = this.recentBlocks.findIndex(block => block.height === blockData.height);
					if (existingBlockIndex !== -1) {
						// Remove the existing block if found
						this.recentBlocks.splice(existingBlockIndex, 1);
					}
					
					// Add new block to the beginning of the array
					this.recentBlocks.unshift(blockData);
					
					// Keep only the last 5 blocks to prevent memory growth
					if (this.recentBlocks.length > 5) {
						this.recentBlocks = this.recentBlocks.slice(0, 5);
					}

					// Update latest block
					this.latestBlock = blockData;
				},

				// Alpine.js lifecycle hook
				destroy() {
					// Remove event listener
					if (this.blockEventListener) {
						document.removeEventListener('block', this.blockEventListener);
						this.blockEventListener = null;
					}
					
					// Clear arrays
					this.recentBlocks = [];
				}
			}
		}

		// Global cleanup on page unload
		window.addEventListener('beforeunload', () => {
			// Cleanup any remaining Alpine components
			if (window.Alpine && window.Alpine.store('cleanup')) {
				window.Alpine.store('cleanup').destroy();
			}
		});
	</script>
}

templ NetworkSidebarFragment(stats *DashboardStats) {
	<div class="">
		<div class="bg-white/90 dark:bg-gray-800/90 backdrop-blur-md rounded-lg p-3 border border-white/20 dark:border-gray-700/50 shadow-lg">
			<h4 class="text-xs font-semibold mb-2 text-gray-900 dark:text-gray-100 uppercase tracking-wide">Network Info</h4>
			<div class="space-y-1.5">
				<div class="flex justify-between">
					<span class="text-xs text-gray-600 dark:text-gray-400">Validators</span>
					<span class="text-xs font-semibold text-gray-900 dark:text-gray-100" x-text="validatorCount">{ fmt.Sprintf("%d", stats.ValidatorCount) }</span>
				</div>
				<template x-if="latestBlock.height > 0">
					<div>
						<div class="flex justify-between">
							<span class="text-xs text-gray-600 dark:text-gray-400">Latest Block</span>
							<a :href="'/block/' + latestBlock.height" class="text-xs font-semibold text-purple-600 dark:text-purple-400 hover:underline" x-text="'#' + latestBlock.height"></a>
						</div>
						<div class="flex justify-between">
							<span class="text-xs text-gray-600 dark:text-gray-400">Proposer</span>
							<a :href="'/validator/' + latestBlock.proposer" class="font-mono text-xs text-purple-600 dark:text-purple-400 hover:underline" x-text="formatProposer(latestBlock.proposer)"></a>
						</div>
					</div>
				</template>
			</div>
		</div>
		<div class="bg-white/90 dark:bg-gray-800/90 backdrop-blur-md rounded-lg p-3 border border-white/20 dark:border-gray-700/50 shadow-lg">
			<h4 class="text-xs font-semibold mb-2 text-gray-900 dark:text-gray-100 uppercase tracking-wide">Recent Proposers</h4>
			<div class="space-y-1">
				<template x-if="recentBlocks.length > 0">
					<template x-for="(block, index) in recentBlocks" :key="block.height">
						<div class="flex items-center justify-between">
							<span class="text-xs text-gray-500 dark:text-gray-500" x-text="'#' + (index + 1)"></span>
							<a :href="'/validator/' + block.proposer" class="font-mono text-xs text-purple-600 dark:text-purple-400 hover:underline truncate" x-text="formatProposer(block.proposer)"></a>
						</div>
					</template>
				</template>
				<template x-if="recentBlocks.length === 0">
					<div class="text-center py-1">
						<p class="text-gray-500 dark:text-gray-400 text-xs">No recent proposers</p>
						<p class="text-xs text-gray-400 dark:text-gray-500">
							if stats.IsSyncing {
								Syncing...
							} else {
								Waiting...
							}
						</p>
					</div>
				</template>
			</div>
		</div>
	</div>
}
