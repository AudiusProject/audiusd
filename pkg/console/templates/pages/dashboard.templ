package pages

import (
	"fmt"
	"github.com/AudiusProject/audiusd/pkg/console/templates"
	"github.com/AudiusProject/audiusd/pkg/console/templates/layouts"
	"github.com/AudiusProject/audiusd/pkg/etl/db"
	"strconv"
	"strings"
)

type DashboardStats struct {
	CurrentBlockHeight           int64
	ChainID                      string
	BPS                          float64
	TPS                          float64
	TotalTransactions            int64
	ValidatorCount               int64
	LatestBlock                  *db.EtlBlock
	RecentProposers              []string
	IsSyncing                    bool
	LatestIndexedHeight          int64
	LatestChainHeight            int64
	BlockDelta                   int64
	TotalTransactions24h         int64
	TotalTransactionsPrevious24h int64
	TotalTransactions7d          int64
	TotalTransactions30d         int64
	AvgBlockTime                 float32 // Average block time from latest SLA rollup in seconds
}

type TransactionTypeBreakdown struct {
	Type  string
	Count int64
	Color string
}

type PlayEvent struct {
	Timestamp string  `json:"timestamp"`
	Lat       float64 `json:"lat"`
	Lng       float64 `json:"lng"`
	Duration  int     `json:"duration"`
}

type SLAPerformanceDataPoint struct {
	RollupID          int32   `json:"rollupId"`
	BlockHeight       int64   `json:"blockHeight"`
	Timestamp         string  `json:"timestamp"`
	ValidatorCount    int32   `json:"validatorCount"`
	HealthyValidators int32   `json:"healthyValidators"`
	BPS               float64 `json:"bps"`
	TPS               float64 `json:"tps"`
	BlockStart        int64   `json:"blockStart"`
	BlockEnd          int64   `json:"blockEnd"`
}

type DashboardProps struct {
	Stats                  *DashboardStats
	TransactionBreakdown   []*TransactionTypeBreakdown
	RecentBlocks           []*db.EtlBlock
	RecentTransactions     []*db.EtlTransaction
	RecentSLARollups       []*db.EtlSlaRollup
	SLAPerformanceData     []*SLAPerformanceDataPoint
	BlockHeights           map[string]int64
	SyncProgressPercentage float64
}

func formatNumber(n int64) string {
	str := strconv.FormatInt(n, 10)
	if len(str) <= 3 {
		return str
	}

	var result strings.Builder
	for i, char := range str {
		if i > 0 && (len(str)-i)%3 == 0 {
			result.WriteString(",")
		}
		result.WriteRune(char)
	}
	return result.String()
}

func getTotalTransactionCount(breakdown []*TransactionTypeBreakdown) int64 {
	var total int64
	for _, b := range breakdown {
		total += b.Count
	}
	return total
}

func getProgressBarClass(percentage float64) string {
	switch {
	case percentage >= 99:
		return "w-full"
	case percentage >= 95:
		return "w-11/12"
	case percentage >= 90:
		return "w-5/6"
	case percentage >= 80:
		return "w-4/5"
	case percentage >= 75:
		return "w-3/4"
	case percentage >= 60:
		return "w-3/5"
	case percentage >= 50:
		return "w-1/2"
	case percentage >= 40:
		return "w-2/5"
	case percentage >= 25:
		return "w-1/4"
	case percentage >= 20:
		return "w-1/5"
	case percentage >= 10:
		return "w-1/12"
	case percentage >= 5:
		return "w-1/24"
	default:
		return "w-px"
	}
}

func getPercentageChangeText(current, previous int64) string {
	if previous == 0 {
		return "No previous data"
	}

	change := float64(current-previous) / float64(previous) * 100
	if change >= 0 {
		return fmt.Sprintf("+%.1f%% from yesterday", change)
	} else {
		return fmt.Sprintf("%.1f%% from yesterday", change)
	}
}

func getPercentageChangeColorClass(current, previous int64) string {
	if previous == 0 {
		return "text-gray-500 dark:text-gray-400"
	}

	change := float64(current-previous) / float64(previous) * 100
	if change >= 0 {
		return "text-green-600 dark:text-green-400"
	} else {
		return "text-red-600 dark:text-red-400"
	}
}

templ Dashboard(props DashboardProps) {
	@layouts.Base("Dashboard") {
		<div class="space-y-6" x-data="blockEvents()" x-init="init()">
			<!-- Section 1: Current Stats -->
			<div class="bg-white dark:bg-[#141414] rounded-lg shadow-xl p-6">
				<div id="stats-header" x-data="blockEvents()" x-init="init()">
					<div class="flex items-center justify-between">
						<div class="flex-1">
							<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Block Height</h4>
							<div class="flex items-center h-12" x-data="animatedNumber()" x-init="init(latestBlock.height)">
								<template x-for="(digit, index) in digits" :key="index">
									<div class="relative h-10 w-6 overflow-hidden flex items-center justify-center">
										<!-- Current digit (slides down when animating) -->
										<div class="absolute inset-0 flex items-center justify-center">
											<span
												class="text-3xl font-bold text-gray-900 dark:text-gray-100 tabular-nums"
												:class="getCurrentDigitClass(digit)"
												x-text="digit.current"
											></span>
										</div>
										<!-- Next digit (slides in from above when animating) -->
										<div class="absolute inset-0 flex items-center justify-center">
											<span
												class="text-3xl font-bold text-gray-900 dark:text-gray-100 tabular-nums"
												:class="getNextDigitClass(digit)"
												x-text="digit.next"
											></span>
										</div>
									</div>
								</template>
							</div>
						</div>
						<div class="flex-1 border-l border-gray-200 dark:border-gray-700 pl-6">
							<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Chain ID</h4>
							<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">{ props.Stats.ChainID }</p>
						</div>
						<div class="flex-none w-32 border-l border-gray-200 dark:border-gray-700 pl-6">
							<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Block Time</h4>
							if props.Stats.AvgBlockTime > 0 {
								<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">{ fmt.Sprintf("%.2fs", props.Stats.AvgBlockTime) }</p>
							} else if props.Stats.BPS > 0 {
								<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">{ fmt.Sprintf("%.2fs", 1.0/props.Stats.BPS) }</p>
								<p class="text-xs text-gray-500 dark:text-gray-400">{ fmt.Sprintf("%.2f BPS", props.Stats.BPS) }</p>
							} else {
								<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">-</p>
								<p class="text-xs text-gray-500 dark:text-gray-400">No data</p>
							}
						</div>
						<div class="flex-none w-40 border-l border-gray-200 dark:border-gray-700 pl-6">
							<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Sync Status</h4>
							if props.Stats.IsSyncing {
								<div class="flex items-center">
									<div class="w-2 h-2 bg-yellow-500 rounded-full mr-2 animate-pulse"></div>
									<p class="text-xl font-bold text-yellow-600 dark:text-yellow-400">Syncing</p>
								</div>
							} else {
								<div class="flex items-center">
									<div class="w-2 h-2 bg-green-500 rounded-full mr-2"></div>
									<p class="text-xl font-bold text-green-600 dark:text-green-400">Synced</p>
								</div>
								<p class="text-xs text-gray-500 dark:text-gray-400">Up to date</p>
							}
						</div>
					</div>
					<!-- Sync Progress Bar -->
					if props.Stats.IsSyncing && props.Stats.LatestChainHeight > 0 {
						<div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
							<div class="flex items-center justify-between mb-2">
								<span class="text-xs font-medium text-gray-600 dark:text-gray-400">
									Sync Progress
									if props.Stats.BlockDelta > 0 {
										| { fmt.Sprintf("%d blocks to go", props.Stats.BlockDelta) }
									}
								</span>
								<span class="text-xs text-gray-500 dark:text-gray-500">
									{ fmt.Sprintf("%d / %d", props.Stats.LatestIndexedHeight, props.Stats.LatestChainHeight) }
									({ fmt.Sprintf("%.1f%%", props.SyncProgressPercentage) })
								</span>
							</div>
							<div class="w-full bg-gray-200 dark:bg-stone-700 rounded-full h-2 relative overflow-hidden">
								<!-- Exact progress representation using calculated percentage -->
								<div
									class={ fmt.Sprintf("bg-purple-600 h-2 rounded-full transition-all duration-300 ease-in-out %s", getProgressBarClass(props.SyncProgressPercentage)) }
								></div>
							</div>
						</div>
					}
				</div>
			</div>
			<!-- Section 2: Live Map & Validator Info -->
			<div class="bg-white dark:bg-[#141414] rounded-lg shadow-xl overflow-hidden">
				<div class="relative">
					<!-- Map - Full Background -->
					<div
						class="relative bg-gray-100 dark:bg-stone-700 h-96 z-10"
						x-data="livePlayMap()"
						x-init="initSSEEventSource(); initMap()"
					>
						<!-- Map container -->
						<div id="playMap" class="w-full h-full"></div>
						<!-- Connection status -->
						<div class="absolute top-4 left-4 bg-black/20 backdrop-blur-sm rounded px-2 py-1" x-show="!connected">
							<span class="text-white/90 text-xs">Connecting...</span>
						</div>
					</div>
					<!-- Network Info Overlay - Left Side (aligned with zoom buttons) -->
					<div class="absolute top-14 left-16 w-56 z-20">
						<div id="network-sidebar" class="space-y-2" x-data="blockEvents()" x-init={ fmt.Sprintf("init({ validatorCount: %d })", props.Stats.ValidatorCount) }>
							@NetworkSidebarFragment(props.Stats)
						</div>
					</div>
				</div>
			</div>
			<!-- Section 3: Transaction Analytics -->
			<div class="bg-white dark:bg-[#141414] rounded-lg shadow-xl p-6">
				<div class="flex items-center justify-between mb-6">
					<h3 class="text-xl font-bold text-gray-900 dark:text-gray-100">Transaction Analytics</h3>
				</div>
				<div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
					<!-- Primary Metrics -->
					<div class="lg:col-span-2 space-y-6">
						<!-- Top row: TPS and Total Transactions -->
						<div class="grid grid-cols-2 gap-6">
							<div id="tps-fragment" hx-get="/fragments/tps" hx-trigger="every 5s" hx-swap="outerHTML">
								@TPSFragment(props.Stats)
							</div>
							<div id="total-transactions-fragment" hx-get="/fragments/total-transactions" hx-trigger="every 10s" hx-swap="outerHTML">
								@TotalTransactionsFragment(props.Stats)
							</div>
						</div>
						<!-- Bottom row: Volume metrics -->
						<div class="grid grid-cols-3 border-t border-gray-200 dark:border-gray-700 pt-6">
							<div class="border-r border-gray-200 dark:border-gray-700 pr-6">
								<div class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-1">24h Volume</div>
								<div class="text-2xl font-light text-gray-900 dark:text-gray-100 mb-1">{ formatNumber(props.Stats.TotalTransactions24h) }</div>
								<div class="text-xs text-gray-500 dark:text-gray-400">Daily rate</div>
							</div>
							<div class="border-r border-gray-200 dark:border-gray-700 pr-6 pl-6">
								<div class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-1">7d Volume</div>
								<div class="text-2xl font-light text-gray-900 dark:text-gray-100 mb-1">{ formatNumber(props.Stats.TotalTransactions7d) }</div>
								<div class="text-xs text-gray-500 dark:text-gray-400">Avg: { formatNumber(props.Stats.TotalTransactions7d / 7) }/day</div>
							</div>
							<div class="pl-6">
								<div class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-1">30d Volume</div>
								<div class="text-2xl font-light text-gray-900 dark:text-gray-100 mb-1">{ formatNumber(props.Stats.TotalTransactions30d) }</div>
								<div class="text-xs text-gray-500 dark:text-gray-400">Avg: { formatNumber(props.Stats.TotalTransactions30d / 30) }/day</div>
							</div>
						</div>
					</div>
					<!-- Transaction Types -->
					<div class="border-l border-gray-200 dark:border-gray-700 pl-6">
						<div class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-4">Transaction Types</div>
						<div class="space-y-3">
							if len(props.TransactionBreakdown) > 0 {
								for _, breakdown := range props.TransactionBreakdown {
									<div class="flex items-center justify-between">
										<span class="text-xs px-2 py-1 bg-gray-100 dark:bg-stone-700 rounded text-gray-600 dark:text-gray-400">{ breakdown.Type }</span>
										<span class="text-sm font-medium text-gray-900 dark:text-gray-100 tabular-nums">{ formatNumber(breakdown.Count) }</span>
									</div>
								}
							} else {
								<div class="text-sm text-gray-500 dark:text-gray-400">No transaction data available</div>
							}
						</div>
					</div>
				</div>
			</div>
			<!-- Section 4: SLA Performance Chart -->
			if props.SLAPerformanceData != nil && len(props.SLAPerformanceData) > 0 {
				<div class="bg-white dark:bg-[#141414] rounded-lg shadow-xl border border-gray-200 dark:border-gray-700 overflow-hidden">
					<div class="bg-white dark:bg-[#141414] px-6 py-4 border-b border-gray-200 dark:border-gray-700">
						<div class="flex items-center justify-between">
							<div class="flex items-center space-x-3">
								<div class="w-3 h-3 bg-purple-500 rounded-full animate-pulse"></div>
								<h2 class="text-lg font-bold text-gray-900 dark:text-gray-100 tracking-wide">Network Performance</h2>
							</div>
							<a href="/rollups" class="text-purple-600 dark:text-purple-400 hover:text-purple-800 dark:hover:text-purple-300 hover:underline text-sm">View rollups →</a>
						</div>
						<div class="mt-3 flex items-center justify-between">
							<div
								class="flex items-center space-x-4 text-xs text-gray-500 dark:text-gray-400"
								x-data="chartMeta()"
								x-init="init()"
								data-chart-data={ templ.JSONString(props.SLAPerformanceData) }
							>
								<div class="text-right">
									<div class="font-medium" x-text="blockRange"></div>
									<div class="text-gray-400" x-text="timeRange"></div>
								</div>
								<div class="w-px h-8 bg-gray-300 dark:bg-[#141414]"></div>
								<div class="flex items-center space-x-1">
									<div class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
									<span class="font-medium">LIVE</span>
								</div>
							</div>
						</div>
					</div>
					<div class="relative h-96 bg-gray-50 dark:bg-[#141414] p-4">
						<canvas
							id="slaPerformanceChart"
							class="w-full h-full"
							x-data="slaChart()"
							x-init="initChart()"
							data-chart-data={ templ.JSONString(props.SLAPerformanceData) }
						></canvas>
					</div>
				</div>
			}
			<!-- Section 5: Recent Blocks & Transactions -->
			<div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
				<!-- Latest Blocks -->
				<div class="bg-white dark:bg-[#141414] rounded-lg shadow-xl p-6">
					<div class="flex justify-between items-center mb-4">
						<h3 class="text-xl font-bold text-gray-900 dark:text-gray-100">Latest Blocks</h3>
						<a href="/blocks" class="text-purple-600 dark:text-purple-400 hover:text-purple-800 dark:hover:text-purple-300 hover:underline text-sm">View all →</a>
					</div>
					if len(props.RecentBlocks) > 0 {
						<div class="space-y-2">
							for _, block := range props.RecentBlocks {
								<div class="flex items-center justify-between py-3 px-4 border border-gray-200 dark:border-gray-700 rounded hover:bg-purple-50 hover:border-purple-200 dark:hover:bg-stone-700 transition-colors">
									<div class="flex items-center gap-4">
										<a href={ templ.SafeURL(fmt.Sprintf("/block/%d", block.BlockHeight)) } class="font-semibold text-purple-600 dark:text-purple-400 hover:underline">
											{ fmt.Sprintf("#%d", block.BlockHeight) }
										</a>
										<a href={ templ.SafeURL(fmt.Sprintf("/validator/%s", block.ProposerAddress)) } class="font-mono text-xs text-purple-600 dark:text-purple-400 hover:underline">
											if len(block.ProposerAddress) > 8 {
												{ block.ProposerAddress[:4] }...{ block.ProposerAddress[len(block.ProposerAddress)-4:] }
											} else {
												{ block.ProposerAddress }
											}
										</a>
									</div>
									<div class="text-xs text-gray-500 dark:text-gray-400">
										if block.BlockTime.Valid {
											@templates.TimeWithTooltip(block.BlockTime.Time)
										} else {
											<span>—</span>
										}
									</div>
								</div>
							}
						</div>
					} else {
						<p class="text-gray-500 dark:text-gray-400">No blocks found</p>
					}
				</div>
				<!-- Latest Transactions -->
				<div class="bg-white dark:bg-[#141414] rounded-lg shadow-xl p-6">
					<div class="flex justify-between items-center mb-4">
						<h3 class="text-xl font-bold text-gray-900 dark:text-gray-100">Latest Transactions</h3>
						<a href="/transactions" class="text-purple-600 dark:text-purple-400 hover:text-purple-800 dark:hover:text-purple-300 hover:underline text-sm">View all →</a>
					</div>
					if len(props.RecentTransactions) > 0 {
						<div class="space-y-2">
							for _, tx := range props.RecentTransactions {
								<div class="flex items-center justify-between py-3 px-4 border border-gray-200 dark:border-gray-700 rounded hover:bg-purple-50 hover:border-purple-200 dark:hover:bg-stone-700 transition-colors">
									<div class="flex items-center gap-4">
										<a href={ templ.SafeURL(fmt.Sprintf("/transaction/%s", tx.TxHash)) } class="font-mono text-sm text-purple-600 dark:text-purple-400 hover:underline">
											if len(tx.TxHash) > 8 {
												{ tx.TxHash[:4] }...{ tx.TxHash[len(tx.TxHash)-4:] }
											} else {
												{ tx.TxHash }
											}
										</a>
										<span class="text-xs px-2 py-1 bg-gray-100 dark:bg-stone-700 rounded text-gray-600 dark:text-gray-400">
											{ tx.TxType }
										</span>
										if blockHeight, exists := props.BlockHeights[tx.TxHash]; exists {
											<a href={ templ.SafeURL(fmt.Sprintf("/block/%d", blockHeight)) } class="text-xs text-purple-600 dark:text-purple-400 hover:underline">
												{ fmt.Sprintf("#%d", blockHeight) }
											</a>
										}
									</div>
									<div class="text-xs text-gray-500 dark:text-gray-400">
										if tx.CreatedAt.Valid {
											@templates.TimeWithTooltip(tx.CreatedAt.Time)
										} else {
											<span>—</span>
										}
									</div>
								</div>
							}
						</div>
					} else {
						<p class="text-gray-500 dark:text-gray-400">No transactions found</p>
					}
				</div>
			</div>
		</div>
		@SSEEventScript()
		@LivePlayMapScript()
		@BlockEventsScript()
		@SLAChartScript()
	}
}

// HTMX Fragment Templates
templ StatsHeaderFragment(stats *DashboardStats, syncProgressPercentage float64) {
	<div id="stats-header" hx-get="/fragments/stats-header" hx-trigger="every 10s" hx-swap="outerHTML" x-data="blockEvents()" x-init="init()">
		<div class="flex items-center justify-between">
			<div class="flex-1">
				<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Block Height</h4>
				<div class="flex items-center h-12" x-data="animatedNumber()" x-init="init(latestBlock.height)">
					<template x-for="(digit, index) in digits" :key="index">
						<div class="relative h-10 w-6 overflow-hidden flex items-center justify-center">
							<!-- Current digit (slides down when animating) -->
							<div class="absolute inset-0 flex items-center justify-center">
								<span
									class="text-3xl font-bold text-gray-900 dark:text-gray-100 tabular-nums"
									:class="getCurrentDigitClass(digit)"
									x-text="digit.current"
								></span>
							</div>
							<!-- Next digit (slides in from above when animating) -->
							<div class="absolute inset-0 flex items-center justify-center">
								<span
									class="text-3xl font-bold text-gray-900 dark:text-gray-100 tabular-nums"
									:class="getNextDigitClass(digit)"
									x-text="digit.next"
								></span>
							</div>
						</div>
					</template>
				</div>
			</div>
			<div class="flex-1 border-l border-gray-200 dark:border-gray-700 pl-6">
				<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Chain ID</h4>
				<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">{ stats.ChainID }</p>
			</div>
			<div class="flex-none w-32 border-l border-gray-200 dark:border-gray-700 pl-6">
				<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Block Time</h4>
				if stats.AvgBlockTime > 0 {
					<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">{ fmt.Sprintf("%.2fs", stats.AvgBlockTime) }</p>
				} else if stats.BPS > 0 {
					<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">{ fmt.Sprintf("%.2fs", 1.0/stats.BPS) }</p>
					<p class="text-xs text-gray-500 dark:text-gray-400">{ fmt.Sprintf("%.2f BPS", stats.BPS) }</p>
				} else {
					<p class="text-3xl font-bold text-gray-900 dark:text-gray-100">-</p>
					<p class="text-xs text-gray-500 dark:text-gray-400">No data</p>
				}
			</div>
			<div class="flex-none w-40 border-l border-gray-200 dark:border-gray-700 pl-6">
				<h4 class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide">Sync Status</h4>
				if stats.IsSyncing {
					<div class="flex items-center">
						<div class="w-2 h-2 bg-yellow-500 rounded-full mr-2 animate-pulse"></div>
						<p class="text-xl font-bold text-yellow-600 dark:text-yellow-400">Syncing</p>
					</div>
				} else {
					<div class="flex items-center">
						<div class="w-2 h-2 bg-green-500 rounded-full mr-2"></div>
						<p class="text-xl font-bold text-green-600 dark:text-green-400">Synced</p>
					</div>
					<p class="text-xs text-gray-500 dark:text-gray-400">Up to date</p>
				}
			</div>
		</div>
		<!-- Sync Progress Bar -->
		if stats.IsSyncing && stats.LatestChainHeight > 0 {
			<div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
				<div class="flex items-center justify-between mb-2">
					<span class="text-xs font-medium text-gray-600 dark:text-gray-400">
						Sync Progress
						if stats.BlockDelta > 0 {
							| { fmt.Sprintf("%d blocks to go", stats.BlockDelta) }
						}
					</span>
					<span class="text-xs text-gray-500 dark:text-gray-500">
						{ fmt.Sprintf("%d / %d", stats.LatestIndexedHeight, stats.LatestChainHeight) }
						({ fmt.Sprintf("%.1f%%", syncProgressPercentage) })
					</span>
				</div>
				<div class="w-full bg-gray-200 dark:[#141414] rounded-full h-2 relative overflow-hidden">
					<!-- Exact progress representation using calculated percentage -->
					<div
						class={ fmt.Sprintf("bg-purple-600 h-2 rounded-full transition-all duration-300 ease-in-out %s", getProgressBarClass(syncProgressPercentage)) }
					></div>
				</div>
			</div>
		}
	</div>
}

templ TPSFragment(stats *DashboardStats) {
	<div id="tps-fragment" hx-get="/fragments/tps" hx-trigger="every 5s" hx-swap="outerHTML" class="border-r border-gray-200 dark:border-gray-700 pr-6">
		<div class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-1">Transactions/sec</div>
		<div class="text-4xl font-light text-gray-900 dark:text-gray-100 mb-1">{ fmt.Sprintf("%.1f", stats.TPS) }</div>
		<div class="text-xs text-gray-500 dark:text-gray-400">30d Avg: { fmt.Sprintf("%.1f", float64(stats.TotalTransactions30d)/(30*24*60*60)) } TPS</div>
	</div>
}

templ TotalTransactionsFragment(stats *DashboardStats) {
	<div id="total-transactions-fragment" hx-get="/fragments/total-transactions" hx-trigger="every 10s" hx-swap="outerHTML" class="pr-6">
		<div class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-1">Total Transactions</div>
		<div class="text-4xl font-light text-gray-900 dark:text-gray-100 mb-1">{ formatNumber(stats.TotalTransactions) }</div>
		<div class={ fmt.Sprintf("text-xs %s", getPercentageChangeColorClass(stats.TotalTransactions24h, stats.TotalTransactionsPrevious24h)) }>{ getPercentageChangeText(stats.TotalTransactions24h, stats.TotalTransactionsPrevious24h) }</div>
	</div>
}

templ SSEEventScript() {
	<script>
		let globalEventSource = null;

		function initSSEEventSource() {
			// Close existing connection if any
			if (globalEventSource) {
				globalEventSource.close();
			}

			globalEventSource = new EventSource('/sse/events');

			// Dispatch custom events for each SSE event
			globalEventSource.onmessage = (event) => {
				try {
					const data = JSON.parse(event.data);
					document.dispatchEvent(new CustomEvent(data.event, { detail: data.data }));
				} catch (e) {
					console.error('Error parsing SSE event data:', e, event.data);
				}
			};

			globalEventSource.onerror = (error) => {
				console.error('SSE connection error:', error);
			};

			globalEventSource.onopen = () => {
				console.log('SSE connection opened');
			};

			// Cleanup on page unload
			window.addEventListener('beforeunload', () => {
				if (globalEventSource) {
					globalEventSource.close();
					globalEventSource = null;
				}
			});

			// Cleanup on page visibility change (mobile browsers)
			document.addEventListener('visibilitychange', () => {
				if (document.hidden && globalEventSource) {
					globalEventSource.close();
					globalEventSource = null;
				} else if (!document.hidden && !globalEventSource) {
					// Reconnect when page becomes visible again
					setTimeout(() => {
						initSSEEventSource();
					}, 1000);
				}
			});

			return globalEventSource;
		}

		// Cleanup when Alpine.js is destroyed
		document.addEventListener('alpine:init', () => {
			Alpine.store('cleanup', {
				eventSource: null,
				init() {
					this.eventSource = initSSEEventSource();
				},
				destroy() {
					if (this.eventSource) {
						this.eventSource.close();
						this.eventSource = null;
					}
				}
			});
		});
	</script>
}

// Live Play Map Alpine.js Component
templ LivePlayMapScript() {
	<script>
		function livePlayMap() {
			return {
				map: null,
				eventSource: null,
				connected: false,
				playMarkers: [],
				playEventListener: null,
				animationFrames: new Set(),
				timeouts: new Set(),
				
				initMap() {
					// Create bound event listener for proper cleanup
					this.playEventListener = (event) => {
						this.addPlayToMap(event.detail);
					};
					document.addEventListener('play', this.playEventListener);

					// Initialize Leaflet map focused on US
					this.map = L.map('playMap').setView([39.0, -110.0], 5);
					
					// Detect dark mode and use appropriate tiles
					const isDarkMode = document.documentElement.classList.contains('dark') || 
					                  window.matchMedia('(prefers-color-scheme: dark)').matches;
					
					if (isDarkMode) {
						// Dark mode tiles
						L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
							attribution: '© OpenStreetMap, © CartoDB',
							subdomains: 'abcd'
						}).addTo(this.map);
					} else {
						// Light mode tiles
						L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
							attribution: '© OpenStreetMap contributors'
						}).addTo(this.map);
					}

					// Setup cleanup on page unload
					window.addEventListener('beforeunload', () => {
						this.cleanup();
					});

					// Setup cleanup on Alpine destroy
					this.$watch('$store.cleanup', () => {
						// This will be called when Alpine is destroyed
					});
				},
				
				addPlayToMap(play) {
					if (!this.map) return;
					
					// Set default duration if not provided
					if (!play.duration) {
						play.duration = 5; // Default 5 seconds
					}
					
					const color = this.getRandomColor();
					
					// Create radar-style animation with expanding circles
					const radarGroup = L.layerGroup().addTo(this.map);
					
					// Create multiple expanding circles for radar effect
					for (let i = 0; i < 3; i++) {
						const timeout = setTimeout(() => {
							const circle = L.circle([play.lat, play.lng], {
								radius: 0,
								fillColor: color,
								color: color,
								weight: 2,
								opacity: 0.8,
								fillOpacity: 0.3
							}).addTo(radarGroup);
							
							// Animate the circle expansion
							let radius = 0;
							let opacity = 0.8;
							const maxRadius = 100000; // 100km in meters
							const animationDuration = 1000; // Fixed 1 second animation duration
							const startTime = Date.now();
							
							const animate = () => {
								const elapsed = Date.now() - startTime;
								const progress = Math.min(elapsed / animationDuration, 1);
								
								radius = maxRadius * progress;
								opacity = 0.8 * (1 - progress);
								
								circle.setRadius(radius);
								circle.setStyle({ 
									opacity: opacity,
									fillOpacity: opacity * 0.3
								});
								
								if (progress < 1) {
									const frameId = requestAnimationFrame(animate);
									this.animationFrames.add(frameId);
								} else {
									radarGroup.removeLayer(circle);
								}
							};
							
							animate();
						}, i * 200); // Stagger each circle by 200ms
						
						this.timeouts.add(timeout);
					}
					
					// Add center dot
					const centerDot = L.circleMarker([play.lat, play.lng], {
						radius: 4,
						fillColor: color,
						color: '#ffffff',
						weight: 2,
						opacity: 1,
						fillOpacity: 1
					}).addTo(radarGroup);
					
					// Add popup with play info
					const timestamp = play.timestamp ? new Date(play.timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
					centerDot.bindPopup(`Play at ${timestamp}`);
					
					// Store group for cleanup
					this.playMarkers.push(radarGroup);
					
					// Remove entire radar group after duration
					const cleanupTimeout = setTimeout(() => {
						if (this.map && this.map.hasLayer(radarGroup)) {
							this.map.removeLayer(radarGroup);
						}
						this.playMarkers = this.playMarkers.filter(m => m !== radarGroup);
					}, play.duration * 1000);
					
					this.timeouts.add(cleanupTimeout);
				},
				
				getRandomColor() {
					const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7'];
					return colors[Math.floor(Math.random() * colors.length)];
				},
				
				cleanup() {
					// Clear all timeouts
					this.timeouts.forEach(timeout => clearTimeout(timeout));
					this.timeouts.clear();
					
					// Cancel all animation frames
					this.animationFrames.forEach(frameId => cancelAnimationFrame(frameId));
					this.animationFrames.clear();
					
					// Remove event listener
					if (this.playEventListener) {
						document.removeEventListener('play', this.playEventListener);
						this.playEventListener = null;
					}
					
					// Clean up map markers
					this.playMarkers.forEach(marker => {
						if (this.map && this.map.hasLayer(marker)) {
							this.map.removeLayer(marker);
						}
					});
					this.playMarkers = [];
					
					// Remove map
					if (this.map) {
						this.map.remove();
						this.map = null;
					}
				},

				// Alpine.js lifecycle hook
				destroy() {
					this.cleanup();
				}
			}
		}
	</script>
}

// Block Events Alpine.js Component
templ BlockEventsScript() {
	<script>
		function animatedNumber() {
			return {
				displayValue: 0,
				digits: [],
				blockEventListener: null,
				animationTimeouts: new Set(),
				isInitialized: false,
				
				init(initialValue) {
					// Only initialize if we have a valid positive block height
					// This prevents flashing to 0 during SSE reconnection
					if (initialValue && initialValue > 0) {
						this.displayValue = initialValue;
						this.updateDigits(this.displayValue);
						this.isInitialized = true;
					} else {
						// Try to get initial value from DOM as fallback
						this.tryInitFromDOM();
					}
					
					// Create bound event listener for proper cleanup
					this.blockEventListener = (event) => {
						if (event.detail && event.detail.height && event.detail.height > 0) {
							// If not initialized yet, use this as initial value
							if (!this.isInitialized) {
								this.displayValue = event.detail.height;
								this.updateDigits(this.displayValue);
								this.isInitialized = true;
							} else if (event.detail.height !== this.displayValue) {
								this.animateToNewValue(event.detail.height);
							}
						}
					};
					
					// Listen directly to block events instead of watching parent data
					document.addEventListener('block', this.blockEventListener);
				},
				
				tryInitFromDOM() {
					// Try to get block height from the stats header as fallback
					const statsHeader = document.querySelector('#stats-header');
					if (statsHeader) {
						const blockHeightEl = statsHeader.querySelector('.text-3xl');
						if (blockHeightEl && blockHeightEl.textContent) {
							const height = parseInt(blockHeightEl.textContent.replace(/,/g, ''));
							if (height > 0) {
								this.displayValue = height;
								this.updateDigits(this.displayValue);
								this.isInitialized = true;
							}
						}
					}
				},
				
				updateDigits(value) {
					const str = value.toString();
					const newDigits = [];
					
					// Pad with leading zeros if necessary to maintain consistent width
					const maxLength = Math.max(str.length, this.digits.length);
					const paddedStr = str.padStart(maxLength, '0');
					
					for (let i = 0; i < paddedStr.length; i++) {
						const digit = parseInt(paddedStr[i]);
						const existingDigit = this.digits[i];
						
						if (existingDigit) {
							// Keep existing digit state but update target
							newDigits.push({
								...existingDigit,
								next: digit,
								isAnimating: existingDigit.current !== digit
							});
						} else {
							// New digit
							newDigits.push({
								current: digit,
								next: digit,
								isAnimating: false
							});
						}
					}
					
					this.digits = newDigits;
				},
				
				animateToNewValue(newValue) {
					if (newValue === this.displayValue || newValue <= 0) return;
					
					this.updateDigits(newValue);
					
					// Start animations for changed digits
					this.digits.forEach((digit, index) => {
						if (digit.isAnimating) {
							this.animateDigit(index);
						}
					});
					
					this.displayValue = newValue;
				},
				
				animateDigit(index) {
					const digit = this.digits[index];
					
					// Mark as animating
					digit.isAnimating = true;
					
					// After animation duration, update the current digit and stop animating
					const timeout = setTimeout(() => {
						digit.current = digit.next;
						digit.isAnimating = false;
						this.animationTimeouts.delete(timeout);
					}, 300); // Animation duration
					
					this.animationTimeouts.add(timeout);
				},
				
				getCurrentDigitClass(digit) {
					if (digit.isAnimating) {
						return 'transform translate-y-full opacity-0 transition-all duration-300 ease-in-out';
					}
					return 'transform translate-y-0 opacity-100';
				},
				
				getNextDigitClass(digit) {
					if (digit.isAnimating) {
						return 'transform translate-y-0 opacity-100 transition-all duration-300 ease-in-out';
					}
					return 'transform -translate-y-full opacity-0';
				},

				// Alpine.js lifecycle hook
				destroy() {
					// Clear all animation timeouts
					this.animationTimeouts.forEach(timeout => clearTimeout(timeout));
					this.animationTimeouts.clear();
					
					// Remove event listener
					if (this.blockEventListener) {
						document.removeEventListener('block', this.blockEventListener);
						this.blockEventListener = null;
					}
				}
			}
		}

		function blockEvents() {
			return {
				recentBlocks: [],
				latestBlock: { height: 0, proposer: '' },
				validatorCount: 0,
				blockEventListener: null,
				
				init(initialState = {}) {
					// Set initial state from server-rendered values
					const networkSidebar = document.querySelector('#network-sidebar');
					const statsHeader = document.querySelector('#stats-header');
					
					// Set initial validator count from server
					if (initialState.validatorCount) {
						this.validatorCount = parseInt(initialState.validatorCount);
					}

					if (networkSidebar) {
						const blockHeightEl = networkSidebar.querySelector('a[href^="/block/"]');
						const proposerEl = networkSidebar.querySelector('a[href^="/validator/"]');

						if (blockHeightEl && proposerEl) {
							this.latestBlock = {
								height: parseInt(blockHeightEl.textContent.replace('#', '')),
								proposer: proposerEl.href.split('/').pop()
							};
						}
					}

					// Also get initial block height from stats header
					if (statsHeader) {
						const blockHeightEl = statsHeader.querySelector('.text-3xl');
						if (blockHeightEl) {
							this.latestBlock.height = parseInt(blockHeightEl.textContent);
						}
					}

					// Create bound event listener for proper cleanup
					this.blockEventListener = (event) => {
						this.handleBlockEvent(event.detail);
					};
					
					document.addEventListener('block', this.blockEventListener);
				},

				formatProposer(proposer) {
					return proposer.length > 12 
						? `${proposer.slice(0, 6)}...${proposer.slice(-4)}`
						: proposer;
				},

				handleBlockEvent(blockData) {
					// Check if we already have this block
					const existingBlockIndex = this.recentBlocks.findIndex(block => block.height === blockData.height);
					if (existingBlockIndex !== -1) {
						// Remove the existing block if found
						this.recentBlocks.splice(existingBlockIndex, 1);
					}
					
					// Add new block to the beginning of the array
					this.recentBlocks.unshift(blockData);
					
					// Keep only the last 5 blocks to prevent memory growth
					if (this.recentBlocks.length > 5) {
						this.recentBlocks = this.recentBlocks.slice(0, 5);
					}

					// Update latest block
					this.latestBlock = blockData;
				},

				// Alpine.js lifecycle hook
				destroy() {
					// Remove event listener
					if (this.blockEventListener) {
						document.removeEventListener('block', this.blockEventListener);
						this.blockEventListener = null;
					}
					
					// Clear arrays
					this.recentBlocks = [];
				}
			}
		}

		// Global cleanup on page unload
		window.addEventListener('beforeunload', () => {
			// Cleanup any remaining Alpine components
			if (window.Alpine && window.Alpine.store('cleanup')) {
				window.Alpine.store('cleanup').destroy();
			}
		});
	</script>
}

// SLA Chart Alpine.js Component with Chart.js
templ SLAChartScript() {
	<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
	<script>
		function chartMeta() {
			return {
				blockRange: '',
				timeRange: '',
				
				init() {
					const dataStr = this.$el.getAttribute('data-chart-data');
					
					try {
						const chartData = JSON.parse(dataStr);
						if (chartData && chartData.length > 0) {
							// Sort by block height
							chartData.sort((a, b) => a.blockHeight - b.blockHeight);
							
							const firstBlock = chartData[0].blockHeight;
							const lastBlock = chartData[chartData.length - 1].blockHeight;
							this.blockRange = `Blocks ${firstBlock.toLocaleString()} - ${lastBlock.toLocaleString()}`;
							
							// Calculate time range
							const firstTime = new Date(chartData[0].timestamp);
							const lastTime = new Date(chartData[chartData.length - 1].timestamp);
							const now = new Date();
							
							// Time since last data point
							const timeSinceMs = now - lastTime;
							const timeSince = this.formatTimeSince(timeSinceMs);
							
							// Duration of the data range
							const durationMs = lastTime - firstTime;
							const duration = this.formatDuration(durationMs);
							
							this.timeRange = `${duration} span • ${timeSince} ago`;
						} else {
							this.blockRange = 'No data available';
							this.timeRange = '';
						}
					} catch (e) {
						console.error('Failed to parse chart meta data:', e);
						this.blockRange = 'Error loading data';
						this.timeRange = '';
					}
				},
				
				formatTimeSince(ms) {
					const seconds = Math.floor(ms / 1000);
					const minutes = Math.floor(seconds / 60);
					const hours = Math.floor(minutes / 60);
					const days = Math.floor(hours / 24);
					
					if (days > 0) return `${days} day${days > 1 ? 's' : ''}`;
					if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''}`;
					if (minutes > 0) return `${minutes} min`;
					return `${seconds} sec`;
				},
				
				formatDuration(ms) {
					const seconds = Math.floor(ms / 1000);
					const minutes = Math.floor(seconds / 60);
					const hours = Math.floor(minutes / 60);
					const days = Math.floor(hours / 24);
					
					if (days > 0) return `${days} day${days > 1 ? 's' : ''}`;
					if (hours > 0) return `${hours}h`;
					if (minutes > 0) return `${minutes}m`;
					return `${seconds}s`;
				}
			}
		}

		function slaChart() {
			return {
				chart: null,
				chartData: [],
				
				initChart() {
					// Get data from the data attribute
					const canvas = document.getElementById('slaPerformanceChart');
					if (!canvas) {
						console.error('Chart canvas not found');
						return;
					}
					
					const dataStr = canvas.getAttribute('data-chart-data');
					if (!dataStr || dataStr === 'null' || dataStr === 'undefined') {
						console.log('No chart data available');
						canvas.style.display = 'none';
						return;
					}
					
					try {
						this.chartData = JSON.parse(dataStr);
					} catch (e) {
						console.error('Failed to parse chart data:', e, 'Raw data:', dataStr);
						this.chartData = [];
						canvas.style.display = 'none';
						return;
					}

					// If no data or invalid data, don't create chart
					if (!this.chartData || !Array.isArray(this.chartData) || this.chartData.length === 0) {
						console.log('Invalid or empty chart data:', this.chartData);
						canvas.style.display = 'none';
						return;
					}

					// Validate each data point
					const validData = this.chartData.filter(point => {
						return point && 
						       typeof point.rollupId === 'number' && 
						       typeof point.blockHeight === 'number' && 
						       typeof point.timestamp === 'string' && 
						       typeof point.validatorCount === 'number' && 
						       typeof point.bps === 'number' && 
						       typeof point.tps === 'number';
					});

					if (validData.length === 0) {
						console.log('No valid data points found');
						canvas.style.display = 'none';
						return;
					}

					this.chartData = validData;

					// Sort data by block height (ascending)
					this.chartData.sort((a, b) => a.blockHeight - b.blockHeight);

					const ctx = canvas.getContext('2d');
					const isDarkMode = document.documentElement.classList.contains('dark') || 
					                  window.matchMedia('(prefers-color-scheme: dark)').matches;

					// Calculate dynamic axis ranges
					const validatorValues = this.chartData.map(point => point.validatorCount);
					const healthyValidatorValues = this.chartData.map(point => point.healthyValidators);
					const bpsValues = this.chartData.map(point => point.bps);
					const tpsValues = this.chartData.map(point => point.tps);
					
					// Combined validator values for left axis (include both total and healthy validators)
					const allValidatorValues = [...validatorValues, ...healthyValidatorValues];
					// Combined performance values for right axis
					const performanceValues = [...bpsValues, ...tpsValues];
					
					// Calculate min/max with padding - now includes both validator count and healthy validator count
					const validatorMin = Math.max(0, Math.min(...allValidatorValues) - 3);
					const validatorMax = Math.max(...allValidatorValues) + 3;
					const performanceMin = Math.max(0, Math.min(...performanceValues) - 1);
					const performanceMax = Math.max(...performanceValues) + 2;

					const labels = this.chartData.map(point => {
						const date = new Date(point.timestamp);
						return date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
					});



					this.chart = new Chart(ctx, {
						type: 'line',
						data: {
							labels: labels,
							datasets: [
								{
									label: 'Validators',
									data: this.chartData.map(point => point.validatorCount),
									borderColor: isDarkMode ? '#60a5fa' : '#2563eb',
									backgroundColor: 'transparent',
									borderWidth: 2,
									fill: false,
									tension: 0.3,
									pointRadius: 0,
									pointHoverRadius: 6,
									pointBackgroundColor: isDarkMode ? '#60a5fa' : '#2563eb',
									pointBorderColor: isDarkMode ? '#1f2937' : '#ffffff',
									pointBorderWidth: 2,
									pointHoverBackgroundColor: isDarkMode ? '#93c5fd' : '#1d4ed8',
									pointHoverBorderColor: isDarkMode ? '#1f2937' : '#ffffff',
									pointHoverBorderWidth: 3,
									yAxisID: 'y'
								},
								{
									label: 'Healthy Validators',
									data: this.chartData.map(point => point.healthyValidators),
									borderColor: isDarkMode ? '#10b981' : '#059669',
									backgroundColor: 'transparent',
									borderWidth: 2,
									fill: false,
									tension: 0.3,
									pointRadius: 0,
									pointHoverRadius: 6,
									pointBackgroundColor: isDarkMode ? '#10b981' : '#059669',
									pointBorderColor: isDarkMode ? '#1f2937' : '#ffffff',
									pointBorderWidth: 2,
									pointHoverBackgroundColor: isDarkMode ? '#34d399' : '#047857',
									pointHoverBorderColor: isDarkMode ? '#1f2937' : '#ffffff',
									pointHoverBorderWidth: 3,
									yAxisID: 'y'
								},
								{
									label: 'BPS',
									data: this.chartData.map(point => point.bps),
									borderColor: isDarkMode ? '#c084fc' : '#7c3aed',
									backgroundColor: 'transparent',
									borderWidth: 2,
									fill: false,
									tension: 0.3,
									pointRadius: 0,
									pointHoverRadius: 6,
									pointBackgroundColor: isDarkMode ? '#c084fc' : '#7c3aed',
									pointBorderColor: isDarkMode ? '#1f2937' : '#ffffff',
									pointBorderWidth: 2,
									pointHoverBackgroundColor: isDarkMode ? '#ddd6fe' : '#5b21b6',
									pointHoverBorderColor: isDarkMode ? '#1f2937' : '#ffffff',
									pointHoverBorderWidth: 3,
									yAxisID: 'y1'
								},
								{
									label: 'TPS',
									data: this.chartData.map(point => point.tps),
									borderColor: isDarkMode ? '#f472b6' : '#db2777',
									backgroundColor: 'transparent',
									borderWidth: 2,
									fill: false,
									tension: 0.3,
									pointRadius: 0,
									pointHoverRadius: 6,
									pointBackgroundColor: isDarkMode ? '#f472b6' : '#db2777',
									pointBorderColor: isDarkMode ? '#1f2937' : '#ffffff',
									pointBorderWidth: 2,
									pointHoverBackgroundColor: isDarkMode ? '#fce7f3' : '#be185d',
									pointHoverBorderColor: isDarkMode ? '#1f2937' : '#ffffff',
									pointHoverBorderWidth: 3,
									yAxisID: 'y1'
								}
							]
						},
						options: {
							responsive: true,
							maintainAspectRatio: false,
							interaction: {
								mode: 'index',
								intersect: false,
							},
							elements: {
								line: {
									borderWidth: 2,
								},
								point: {
									radius: 0,
									hoverRadius: 6,
									borderWidth: 2,
									hoverBorderWidth: 3
								}
							},
							animation: {
								duration: 300,
								easing: 'easeInOutQuart'
							},
							plugins: {
								title: {
									display: false
								},
								legend: {
									display: true,
									position: 'top',
									align: 'start',
									labels: {
										usePointStyle: true,
										pointStyle: 'rect',
										color: isDarkMode ? '#d1d5db' : '#4b5563',
										font: {
											size: 11,
											weight: '400'
										},
										padding: 20,
										pointStyleWidth: 15,
										generateLabels: function(chart) {
											const original = Chart.defaults.plugins.legend.labels.generateLabels;
											const labels = original.call(this, chart);
											
											labels.forEach((label, index) => {
												const dataset = chart.data.datasets[index];
												if (dataset) {
													label.fillStyle = dataset.borderColor;
													label.strokeStyle = dataset.borderColor;
													label.pointStyle = 'rect';
												}
											});
											
											return labels;
										}
									}
								},
								tooltip: {
									backgroundColor: isDarkMode ? 'rgba(17, 24, 39, 0.96)' : 'rgba(255, 255, 255, 0.96)',
									titleColor: isDarkMode ? '#f3f4f6' : '#1f2937',
									bodyColor: isDarkMode ? '#e5e7eb' : '#374151',
									borderColor: isDarkMode ? '#6b7280' : '#d1d5db',
									borderWidth: 1,
									cornerRadius: 8,
									displayColors: true,
									titleFont: {
										size: 12,
										weight: '600'
									},
									bodyFont: {
										size: 10,
										weight: '400'
									},
									padding: 12,
									maxWidth: 350,
									titleSpacing: 4,
									bodySpacing: 2,
									callbacks: {
										title: (context) => {
											const dataIndex = context[0].dataIndex;
											const point = this.chartData[dataIndex];
											if (!point) return '';
											const date = new Date(point.timestamp);
											return date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
										},
										label: (context) => {
											const datasetLabel = context.dataset.label;
											const value = context.parsed.y;
											const dataIndex = context.dataIndex;
											const point = this.chartData[dataIndex];
											
											if (datasetLabel === 'Validators') {
												return `Validators: ${value}`;
											} else if (datasetLabel === 'Healthy Validators') {
												return `Healthy Validators: ${value}`;
											} else if (datasetLabel === 'BPS') {
												// Convert BPS to Block Time for better readability
												const blockTime = point && point.bps > 0 ? (1 / point.bps) : 0;
												return `Block Time: ${blockTime.toFixed(2)}s`;
											} else if (datasetLabel === 'TPS') {
												return `Transactions/sec: ${value.toFixed(2)}`;
											}
											return '';
										},
										afterBody: (context) => {
											const dataIndex = context[0].dataIndex;
											const point = this.chartData[dataIndex];
											if (!point) return [];
											return [
												'',
												`Block ${point.blockHeight.toLocaleString()}`
											];
										}
									}
								}
							},
							scales: {
								x: {
									display: true,
									title: {
										display: false
									},
									ticks: {
										color: isDarkMode ? '#9ca3af' : '#6b7280',
										maxTicksLimit: 8,
										font: {
											weight: '400',
											size: 10
										}
									},
									grid: {
										color: isDarkMode ? '#374151' : '#f3f4f6',
										lineWidth: 0.5,
										borderDash: [3, 3]
									},
									border: {
										color: isDarkMode ? '#4b5563' : '#d1d5db',
										width: 0.5
									}
								},
								y: {
									type: 'linear',
									display: true,
									position: 'left',
									min: validatorMin,
									max: validatorMax,
									title: {
										display: true,
										text: 'Validators',
										color: isDarkMode ? '#9ca3af' : '#6b7280',
										font: {
											weight: '500',
											size: 11
										}
									},
									ticks: {
										color: isDarkMode ? '#9ca3af' : '#6b7280',
										font: {
											weight: '400',
											size: 10
										}
									},
									grid: {
										color: isDarkMode ? '#374151' : '#f3f4f6',
										lineWidth: 0.5,
										borderDash: [3, 3]
									},
									border: {
										color: isDarkMode ? '#4b5563' : '#d1d5db',
										width: 0.5
									}
								},
								y1: {
									type: 'linear',
									display: true,
									position: 'right',
									min: performanceMin,
									max: performanceMax,
									title: {
										display: true,
										text: 'Performance (BPS/TPS)',
										color: isDarkMode ? '#9ca3af' : '#6b7280',
										font: {
											weight: '500',
											size: 11
										}
									},
									ticks: {
										color: isDarkMode ? '#9ca3af' : '#6b7280',
										font: {
											weight: '400',
											size: 10
										}
									},
									grid: {
										drawOnChartArea: false,
									},
									border: {
										color: isDarkMode ? '#4b5563' : '#d1d5db',
										width: 0.5
									}
								}
							},
							onClick: (event, elements) => {
								if (elements.length > 0) {
									const dataIndex = elements[0].index;
									const point = this.chartData[dataIndex];
									if (point && point.rollupId) {
										// Navigate to rollup details page
										window.location.href = `/validators/uptime/${point.rollupId}`;
									}
								}
							},
							onHover: (event, elements) => {
								const canvas = event.native.target;
								canvas.style.cursor = elements.length > 0 ? 'pointer' : 'default';
							},

							layout: {
								padding: {
									left: 10,
									right: 10,
									top: 5,
									bottom: 5
								}
							}
						}
					});
				},





				// Alpine.js lifecycle hook
				destroy() {
					if (this.chart) {
						this.chart.destroy();
						this.chart = null;
					}
				}
			}
		}
	</script>
}

templ NetworkSidebarFragment(stats *DashboardStats) {
	<div class="">
		<div class="bg-white/90 dark:bg-[#141414]/90 backdrop-blur-md rounded-lg p-3 border border-white/20 dark:border-gray-700/50 shadow-lg">
			<h4 class="text-xs font-semibold mb-2 text-gray-900 dark:text-gray-100 uppercase tracking-wide">Network Info</h4>
			<div class="space-y-1.5">
				<div class="flex justify-between">
					<span class="text-xs text-gray-600 dark:text-gray-400">Validators</span>
					<span class="text-xs font-semibold text-gray-900 dark:text-gray-100" x-text="validatorCount">{ fmt.Sprintf("%d", stats.ValidatorCount) }</span>
				</div>
				<template x-if="latestBlock.height > 0">
					<div>
						<div class="flex justify-between">
							<span class="text-xs text-gray-600 dark:text-gray-400">Latest Block</span>
							<a :href="'/block/' + latestBlock.height" class="text-xs font-semibold text-purple-600 dark:text-purple-400 hover:underline" x-text="'#' + latestBlock.height"></a>
						</div>
						<div class="flex justify-between">
							<span class="text-xs text-gray-600 dark:text-gray-400">Proposer</span>
							<a :href="'/validator/' + latestBlock.proposer" class="font-mono text-xs text-purple-600 dark:text-purple-400 hover:underline" x-text="formatProposer(latestBlock.proposer)"></a>
						</div>
					</div>
				</template>
			</div>
		</div>
		<div class="bg-white/90 dark:bg-[#141414]/90 backdrop-blur-md rounded-lg p-3 border border-white/20 dark:border-gray-700/50 shadow-lg">
			<h4 class="text-xs font-semibold mb-2 text-gray-900 dark:text-gray-100 uppercase tracking-wide">Recent Proposers</h4>
			<div class="space-y-1">
				<template x-if="recentBlocks.length > 0">
					<template x-for="(block, index) in recentBlocks" :key="block.height">
						<div class="flex items-center justify-between">
							<span class="text-xs text-gray-500 dark:text-gray-500" x-text="'#' + (index + 1)"></span>
							<a :href="'/validator/' + block.proposer" class="font-mono text-xs text-purple-600 dark:text-purple-400 hover:underline truncate" x-text="formatProposer(block.proposer)"></a>
						</div>
					</template>
				</template>
				<template x-if="recentBlocks.length === 0">
					<div class="text-center py-1">
						<p class="text-gray-500 dark:text-gray-400 text-xs">No recent proposers</p>
						<p class="text-xs text-gray-400 dark:text-gray-500">
							if stats.IsSyncing {
								Syncing...
							} else {
								Waiting...
							}
						</p>
					</div>
				</template>
			</div>
		</div>
	</div>
}
